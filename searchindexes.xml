<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>go自动化生成数据库curd代码（五）：面向接口编程</title><url>/post/project-sqlboy-5.html</url><categories><category>项目实战</category></categories><tags><tag>go</tag><tag>generate</tag><tag>sqlboy</tag><tag>设计模式</tag></tags><content type="html"><![CDATA[上一节过后，我们已经完成了所有代码的生成工作，最后的任务就是将解析，生成的模块全部集成在一起，并对外提供命令行调用（cmd）。
抽象接口 在编写代码之前，我的第一个工作，就是针对解析以及生成模块，抽象出两大类接口，解析的以及生成的接口。 这是因为，我的主逻辑不能够依赖底层的模块，而是依赖定义的接口，这样能更好维护项目，且达到解耦的目的，而我的底层模块只需要关注自己的职责，不关注上层的调用。
type Parser interface { Name() string Parse(interface{}) (interface{}, error) } type Generator interface { Name() string Generate(interface{}) (*bytes.Buffer, error) } 由于AST和ANTRL的输入和输出不确定，所以对Parser的抽象的入参和出参都是interface{}，ANTRL的实现如下，我们需要定义输入输出方便外部调用
type AntlrParseIn struct { Stmt string } type AntlrParseOut struct { antlrParser.TableAttr } type AntlrParser struct{} func (*AntlrParser) Name() string { return &#34;AntlrParser&#34; } func (*AntlrParser) Parse(in interface{}) (interface{}, error) { parseIn, ok := in.(AntlrParseIn) if !ok { return nil, errors.New(&#34;parse in type error&#34;) } attr, errs := parseStmt(parseIn.Stmt) if len(errs) != 0 { return nil, errs[0] } return AntlrParseOut{TableAttr: attr}, nil } Generator只有输入定义为interface{}，输出可以都定义为*bytes.Buffer，因为最后都是需要生成文件。 这里实现的代码就不贴了，和上面的类似。
事件总线 有了第一步的抽象，我发现解析以及生成模块数量比较多，如果要将他们集成在一起，主逻辑会变得复杂臃肿，模块调用之间相互依赖，后期新增删减模块将会异常恶心。 于是这里使用了事件总线（看到ANTLR runtime包受到的启发），事件总线是发布订阅的一种实现，允许不同的组件之间进行彼此通信而又不需要相互依赖，达到一种解耦的目的。 我参考了网上的go事件总线代码，利用反射去实现，而且是异步，性能高
type Topic string type Bus interface { Subscribe(topic Topic, handler interface{}) error Publish(topic Topic, args ...interface{}) } type AsyncEventBus struct { handlers map[Topic][]reflect.Value lock sync.Mutex } func NewAsyncEventBus() *AsyncEventBus { return &amp;AsyncEventBus{ handlers: map[Topic][]reflect.Value{}, lock: sync.Mutex{}, } } func (bus *AsyncEventBus) Subscribe(topic Topic, f interface{}) error { bus.lock.Lock() defer bus.lock.Unlock() v := reflect.ValueOf(f) if v.Type().Kind() != reflect.Func { return errors.New(&#34;handler is not a function&#34;) } handler, ok := bus.handlers[topic] if !ok { handler = []reflect.Value{} } handler = append(handler, v) bus.handlers[topic] = handler return nil } func (bus *AsyncEventBus) Publish(topic Topic, args ...interface{}) { handlers, ok := bus.handlers[topic] if !ok { fmt.Println(&#34;not found handlers in topic:&#34;, topic) return } params := make([]reflect.Value, len(args)) for i, arg := range args { params[i] = reflect.ValueOf(arg) } for i := range handlers { go handlers[i].Call(params) } } 有了对解析，生成的抽象以及事件总线后，我们就可以开始编写主逻辑了。
主逻辑 先定义我们的结构
type Boy struct { file string // sql定义文件路径  mode GenMode // 生成代码模式 gorm/sqlx  genPackage string // 生成包名  bus *bus.AsyncEventBus // 事件总线  err chan error // 错误信号  done chan struct{} // 完成信号  data chan interface{} // 数据信号 } 在New结构体时使用了optional设计模式，方便后续新增参数
type Option func(*Boy) func Mode(mode GenMode) Option { return func(boy *Boy) { boy.mode = mode } } func NewBoy(filePath string, opts ...Option) *Boy { boy := &amp;Boy{ file: filePath, mode: ModeGorm, err: make(chan error), done: make(chan struct{}), data: make(chan interface{}, 10), } for _, opt := range opts { opt(boy) } boy.register() return boy } 事件总线初始化
func (b *Boy) register() { eventBus := bus.NewAsyncEventBus() _ = eventBus.Subscribe(TopicAstParse, b.eventAstParse) _ = eventBus.Subscribe(TopicAntlrParse, b.eventAntlrParse) _ = eventBus.Subscribe(TopicAssertGenerate, b.eventAssertGenerate) _ = eventBus.Subscribe(TopicModelGenerate, b.eventModelGenerate) _ = eventBus.Subscribe(TopicDaoGenerate, b.eventDaoGenerate) _ = eventBus.Subscribe(TopicTxGenerate, b.eventTxGenerate) _ = eventBus.Subscribe(TopicQueryGenerate, b.eventQueryGenerate) b.bus = eventBus } 相对应的解析和生成函数，parse如果解析成功则会发数据，失败则会发错误的信号，generate如果生成成功则会生成文件，生成后发送完成的信号，反之则发错误的信号。
func (b *Boy) parse(parser inter.Parser, in interface{}) { res, err := parser.Parse(in) if err != nil { b.err &lt;- fmt.Errorf(&#34;%s:%w&#34;, parser.Name(), err) return } b.data &lt;- res } func (b *Boy) generate(gen inter.Generator, in interface{}, file string) { buf, err := gen.Generate(in) if err != nil { b.err &lt;- fmt.Errorf(&#34;%s:%w&#34;, gen.Name(), err) return } source, err := format.Source(buf.Bytes()) if err != nil { b.err &lt;- fmt.Errorf(&#34;%s:%w&#34;, gen.Name(), err) return } if err = os.WriteFile(b.genPath(file), source, 0664); err != nil { b.err &lt;- fmt.Errorf(&#34;%s:%w&#34;, gen.Name(), err) return } b.done &lt;- struct{}{} } 然后是主逻辑，主要处理数据信号，错误信号以及完成信号，可以看到有了事件总线后代码更加清晰，而且异步效率更高。
func (b *Boy) Do() error { b.bus.Publish(TopicAstParse) var genTables, genCount int tables := make(map[string][]parserAntlr.ColumnDecl) for { select { case data := &lt;-b.data: switch data.(type) { case parser.AstParseOut: res := data.(parser.AstParseOut) genTables = len(res.Stmt) b.genPackage = res.PackageName b.bus.Publish(TopicDaoGenerate) b.bus.Publish(TopicTxGenerate) b.bus.Publish(TopicAssertGenerate, res.Stmt) for _, stmt := range res.Stmt { s, err := strconv.Unquote(stmt) if err != nil { return err } b.bus.Publish(TopicAntlrParse, s) } case parser.AntlrParseOut: res := data.(parser.AntlrParseOut) tables[res.TableName] = res.Columns b.bus.Publish(TopicQueryGenerate, b.transRenderData(res)) if len(tables) == genTables { b.bus.Publish(TopicModelGenerate, tables) } } case &lt;-b.done: genCount++ // assert,model,dao,tx is 4 file 	if genCount &gt;= genTables+4 { return nil } case err := &lt;-b.err: return err default: continue } } } cmd 完成主逻辑后，就到我们的命令了，我们规定至少要有一个参数，就是SQL的文件路径，然后只有mode一个选项，默认是生成gorm代码。
const ( usage = `sqlboy [packages] sqlboy $path -mode gorm Find more information at: https://github.com/lemon-1997/sqlboy ` ) func main() { log.SetFlags(0) log.SetPrefix(&#34;sqlboy:&#34;) if len(os.Args) &lt; 2 { log.Fatal(&#34;no specify file&#34;) } flag.Usage = func() { fmt.Print(usage) flag.PrintDefaults() } flag.Parse() var mode string fs := flag.NewFlagSet(&#34;sqlboy&#34;, flag.ExitOnError) fs.StringVar(&amp;mode, &#34;mode&#34;, &#34;&#34;, &#34;gorm or sqlx&#34;) _ = fs.Parse(os.Args[2:]) var opts []sqlboy.Option if mode != &#34;&#34; { genMode := sqlboy.GenMode(mode) if genMode != sqlboy.ModeGorm &amp;&amp; genMode != sqlboy.ModeSqlx { log.Fatalf(&#34;mode %s is not gorm or sqlx&#34;, mode) } opts = append(opts, sqlboy.Mode(genMode)) } boy := sqlboy.NewBoy(os.Args[1], opts...) err := boy.Do() if err != nil { log.Fatal(err) } log.Printf(&#34;generate success&#34;) os.Exit(0) } 测试 先安装命令
go install github.com/lemon-1997/sqlboy/cmd/sqlboy@latest 创建我们的文件，stmt.go，文件内容如下
const ( order = ` -- order_info definition CREATE TABLE &#39;order_info&#39; ( &#39;id&#39; int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;自增ID&#39;, &#39;order_id&#39; varchar(20) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;订单号&#39;, &#39;status&#39; tinyint(3) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;订单状态&#39;, &#39;created_at&#39; timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;, &#39;updated_at&#39; timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;, PRIMARY KEY (&#39;id&#39;), UNIQUE KEY &#39;uk_order&#39; (&#39;order_id&#39;) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=&#39;订单表&#39;; ` product = ` -- product_info definition CREATE TABLE &#39;product_info&#39; ( &#39;id&#39; int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;自增ID&#39;, &#39;product_id&#39; varchar(20) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;商品编号&#39;, &#39;sku_id&#39; varchar(20) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;sku&#39;, &#39;status&#39; tinyint(3) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;商品状态&#39;, &#39;created_at&#39; timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;, &#39;updated_at&#39; timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;, PRIMARY KEY (&#39;id&#39;), UNIQUE KEY &#39;uk_product&#39; (&#39;product_id&#39;, &#39;sku_id&#39;) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=&#39;商品表&#39;; ` ) 生成gorm代码
sqlboy ./stmt.go -mode gorm 生成sqlx代码
sqlboy ./stmt.go -mode sqlx 小结 终于完成了项目和blog的更新，很开心，不过这个系列五篇blog更新的比较仓促，写的匆忙，有许多地方没有写好，因为接下来我有其他事，所以不得不连续五天更新把这个系列完结。 如果对sqlboy感兴趣的话，也欢迎大家使用，有问题可以在github提issue，感谢观看。
项目源码：https://github.com/lemon-1997/sqlboy
]]></content></entry><entry><title>go自动化生成数据库curd代码（四）：模板生成</title><url>/post/project-sqlboy-4.html</url><categories><category>项目实战</category></categories><tags><tag>go</tag><tag>generate</tag><tag>sqlboy</tag><tag>template</tag></tags><content type="html"><![CDATA[上一节我们完成了对SQL的解析，得到了表的相关信息。根据这些信息，我们就可以确定表相对应的curd代码，生成代码我们使用go自带的标准包text/template。 下面将为大家介绍template，并使用template实现代码生成功能。
template使用 模板数据 下面的例子，执行完会输出10 items
type Data struct { Count uint } tmpl, err := template.New(&#34;test&#34;).Parse(&#34;{{.Count}} items&#34;) if err != nil { panic(err) } err = tmpl.Execute(os.Stdout, Data{Count: 10}) if err != nil { panic(err) } 模板里{{.Count}}指的从当前对象取Count变量，其中.指的就是当前对象，也就是我们传入的Data对象，所以最终{{.Count}}会被替换成10，这也是最基础的用法。
空白去除 假设有以下模板
&#34;{{23 -}} &lt; {{- 45}}&#34; 最终的结果是
&#34;23&lt;45&#34; -}}与{{-是template规定的一种语法，-}}表示去除后面的空格，反之同理。去除空白是一个很实用的功能，后面我将利用他去除多余的空行。 如果没有这个功能，我们的模板文件将会变得很拥挤，难以维护。所以，要多利用去除空白，让我们的模板变得更清晰。
常用的Action 介绍两个比较常用的，一个是条件判断
{{if pipeline}} T1 {{else if pipeline}} T0 {{end}} 另一个是遍历，这里要注意的是作用域的问题，range里面的作用域{{.}}实际上是你遍历的对象，而不再是顶层的渲染对象。
{{range pipeline}} T1 {{end}} 这两个都比较简单，后面会使用到。
变量 我们还可以在模板定义我们的变量
$variable := pipeline $variable = pipeline range $index, $element := pipeline 函数 template有内置函数供我们使用，以下摘自go官方文档
and Returns the boolean AND of its arguments by returning the first empty argument or the last argument. That is, &#34;and x y&#34; behaves as &#34;if x then y else x.&#34; Evaluation proceeds through the arguments left to right and returns when the result is determined. call Returns the result of calling the first argument, which must be a function, with the remaining arguments as parameters. Thus &#34;call .X.Y 1 2&#34; is, in Go notation, dot.X.Y(1, 2) where Y is a func-valued field, map entry, or the like. The first argument must be the result of an evaluation that yields a value of function type (as distinct from a predefined function such as print). The function must return either one or two result values, the second of which is of type error. If the arguments don&#39;t match the function or the returned error value is non-nil, execution stops. html Returns the escaped HTML equivalent of the textual representation of its arguments. This function is unavailable in html/template, with a few exceptions. index Returns the result of indexing its first argument by the following arguments. Thus &#34;index x 1 2 3&#34; is, in Go syntax, x[1][2][3]. Each indexed item must be a map, slice, or array. slice slice returns the result of slicing its first argument by the remaining arguments. Thus &#34;slice x 1 2&#34; is, in Go syntax, x[1:2], while &#34;slice x&#34; is x[:], &#34;slice x 1&#34; is x[1:], and &#34;slice x 1 2 3&#34; is x[1:2:3]. The first argument must be a string, slice, or array. js Returns the escaped JavaScript equivalent of the textual representation of its arguments. len Returns the integer length of its argument. not Returns the boolean negation of its single argument. or Returns the boolean OR of its arguments by returning the first non-empty argument or the last argument, that is, &#34;or x y&#34; behaves as &#34;if x then x else y&#34;. Evaluation proceeds through the arguments left to right and returns when the result is determined. print An alias for fmt.Sprint printf An alias for fmt.Sprintf println An alias for fmt.Sprintln urlquery Returns the escaped value of the textual representation of its arguments in a form suitable for embedding in a URL query. This function is unavailable in html/template, with a few exceptions. 不仅如此，还支持我们自定义函数，这个下面将会讲到，有了自定义函数，模板渲染也将变得更加灵活。
模板定义 我们还可以定义我们的模板（定义不会输出）
{{define &#34;T1&#34;}}ONE{{end}} 使用定义的模板（输出模板T1定义的内容）
{{template &#34;T1&#34;}} 了解了template的基本语法后，就可以开发了。
静态文件 我把生成的文件分成静态和动态，静态是指不依赖数据表，文件内容始终一样的，只有包名是不确定，需要我们传入。 静态有dao.go以及transaction.go文件，先把渲染函数实现。
func render(tmpl string, wr io.Writer, data interface{}) error { t, err := template.New(tmpl).Parse(tmpl) if err != nil { return err } return t.Execute(wr, data) } 而我们的模板只有一处是变化的，就是包名package {{.}}，我们直接用{{.}}，所以渲染的调用方式类似下面这样
var packageName string var buf bytes.Buffer err := render(tmpl, &amp;buf, packageName) if err != nil{ return err } 动态文件 动态文件在这里只有curd代码，表对应的结构体代码已经交给AST生成，这里就不再说了，只讲template部分。 由于curd代码比较复杂，所以我们需要用到自定义函数，自定义函数是这样使用的
funcMap := template.FuncMap{ &#34;caseExport&#34;: camelCaseExport, &#34;caseInternal&#34;: camelCaseInternal, } t, err := template.New(tmpl).Funcs(funcMap).Parse(tmpl) if err != nil { return err } return t.Execute(wr, data) camelCaseExport，camelCaseInternal是我自定义的函数，功能是把变量转化成驼峰命名，一个是可导出的命名（首字母大写），一个是内部的命名（首字母小写）。 在模板文件中，可以直接调用自定义函数
{{- $tableExport := caseExport .Table -}} {{- $tableInternal := caseInternal .Table -}} 这里定义了两个变量，分别是表名的导出命名和内部命名，后续直接引用变量就行。在编写模板文件时，难点在于需要生成主键，以及唯一键的curd代码。 我们可以先定义好渲染的变量
type Column struct { Name string Type string IsNotNull bool } type QueryData struct { Package string Table string Columns []Column PrimaryKey []Column UniqueKeys [][]Column ImportSqlx bool } 以唯一键为例，我们需要遍历，表中定义的唯一键
// keyFunSign表示遍历传入的唯一键，并将其变成导出命名，比如我们有一组唯一键（`id`, `count`），那么将会变成：IdCount {{- define &#34;keyFunSign&#34; -}} {{range .}}{{caseExport .Name}}{{end}} {{- end -}} // keyParams表示遍历传入的唯一键，比如我们有一组唯一键（`id`, `count`），将会生成：, id int64, count int64 {{- define &#34;keyParams&#34; -}} {{range .}}, {{caseInternal .Name}} {{.Type}}{{end}} {{- end -}} {{- range .UniqueKeys}} FindBy{{template &#34;keyFunSign&#34; .}}(ctx context.Context{{template &#34;keyParams&#34; .}}) (*{{$tableExport}}, error) UpdateBy{{template &#34;keyFunSign&#34; .}}(ctx context.Context, {{$tableInternal}} *{{$tableExport}}) error DeleteBy{{template &#34;keyFunSign&#34; .}}(ctx context.Context{{template &#34;keyParams&#34; .}}) error {{- end}} 其他的过程都大同小异，只不过生成sqlx代码会复杂点，因为存在null特殊结构，而且还需要拼接sql，不过也差不多，花点时间加上自定义函数的帮助也能够实现，这里就不再展开描述。
小结 在这节过后，我们已经完成了90%的工作，所以的模块，功能已经实现。剩下的任务就是将这些模块拼接，集成使用，由于模块比较分散，组装也不是件容易的事，这个我会在下一篇文章讲到。
项目源码：https://github.com/lemon-1997/sqlboy
]]></content></entry><entry><title>go自动化生成数据库curd代码（三）：ANTLR解析SQL</title><url>/post/project-sqlboy-3.html</url><categories><category>项目实战</category></categories><tags><tag>go</tag><tag>generate</tag><tag>sqlboy</tag><tag>ANTLR</tag></tags><content type="html"><![CDATA[在上一节我们了解了go的抽象语法树AST，并利用go提供的AST包拿到了用户定义的sql。接下来就是如何解析sql，将sql语句中的表名，列字段的名称，类型等关键信息提取出来。 这就需要我们的语法分析了，在本项目中我们决定采用ANTLR来完成此任务，他是一个强大的工具，下文我将为大家介绍是如何实现的。
ANTLR 简介 再讲ANTLR之前，还是想先提一下yacc。yacc是比较出名的语法分析器，不过年代久远，诞生于上个世纪70年代，yacc需要与lex一起才能实现完整的语法树构建。 lex是词法分析器，用于分割语句中的词块，也就是token。go官方也提供了goyacc给我们使用，网上也有关于yacc解析sql的源码。 不过我们还是选择了使用更多的ANTLR，ANTLR目前仍在维护，实现起来比较简单，开发快，还支持所有主流语言，还提供了可视化的语法树，debug特别方便。
安装 安装ANTLR有两种方式，最简单的是用pip3安装。因为我本机有python3，所以很方便。
$ pip install antlr4-tools 执行命令
$ antlr4 Downloading antlr4-4.11.1-complete.jar ANTLR tool needs Java to run; install Java JRE 11 yes/no (default yes)? y Installed Java in /Users/parrt/.jre/jdk-11.0.15+10-jre; remove that dir to uninstall ANTLR Parser Generator Version 4.11.1 -o ___ specify output directory where all output is generated -lib ___ specify location of grammars, tokens files ... 如果上面的命令都没问题，就是安装成功了，我们可以尝试下，比如实现一个计算器。 先创建Expr.g4，文件名必须与grammar相对应
grammar Expr;	prog:	expr EOF ; expr:	expr (&#39;*&#39;|&#39;/&#39;) expr |	expr (&#39;+&#39;|&#39;-&#39;) expr |	INT |	&#39;(&#39; expr &#39;)&#39; ; NEWLINE : [\r\n]+ -&gt; skip; INT : [0-9]+ ; 并使用强大的gui功能（语法树）
antlr4-parse Expr.g4 prog -gui 解析SQL 在编写规则的时候，本来是花了几天时间去实现，完成了表名以及id的定义，不过最后还是发现单单一个建表语句就有很多的规则。 如果单靠自己实现，可能会覆盖不全，而且我平时上班，可能需要花一个月的时间，写这个对我来说帮助也不是很大。 所以，我参照了ANTLR官方mysql的语法（ANTLR官方提供了大量的例子，有兴趣的可以去看看），稍微改造了下，只留下了建表的语法，其余的全部被我删除。 不过，lexer那里还是全部保留下来，虽然有很多token没有使用，考虑涉及到关键字的匹配分词，我都没删。 官方提供的语法虽然很牛逼，不过还是有好几个bug（有些规则为了复用，导致一些根本不会出现在建表规则的也匹配到了），不过这倒不影响，我们的功能要求是能解析，你只要能把正确的解析出来就行。 但是这里也不是说直接拷贝过来就完事，还是要考虑几个问题，解析是不支持多条语句的，如果多个表定义多个变量，分多次解析就行，表名也要支持db.tbl这种情况，mysql字段类型go中类型的转化问题，这些问题我都交给了运行时去解决。
运行时解析 先定义我们解析的结果
type ColumnDecl struct { Decl string // sql字段定义，用于debug  Name string // 字段名称  Comment string // 字段描述  SqlType string // mysql中的类型  GoType GoType // go中对应的类型  IsNotNull bool // 是否可以为空（sqlx有Null类型） } // 索引（用于生成curd代码的查询条件） type ColumnIndex struct { Decl string Columns []ColumnDecl } type TableAttr struct { TableName string // 表名  Columns []ColumnDecl // 字段  PrimaryKey ColumnIndex // 主键  UniqueKeys []ColumnIndex // 唯一键 } GoType的定义
type GoType string const ( Invalid = &#34;invalid&#34; Bool = &#34;bool&#34; Int8 = &#34;int8&#34; Int16 = &#34;int16&#34; Int32 = &#34;int32&#34; Int64 = &#34;int64&#34; Uint8 = &#34;uint8&#34; Uint16 = &#34;uint16&#34; Uint32 = &#34;uint32&#34; Uint64 = &#34;uint64&#34; Float32 = &#34;float32&#34; Float64 = &#34;float64&#34; String = &#34;string&#34; Time = &#34;time.Time&#34; SliceByte = &#34;[]byte&#34; SliceUint8 = &#34;[]uint8&#34; ) 定义好解析结果后，我们先用ANTLR生成代码
antlr4 -Dlanguage=Go *.g4 生成之后，我们实现自己的listener
type StmtListener struct { *BaseStmtParserListener column ColumnDecl TableAttr } func NewStmtListener() *StmtListener { return new(StmtListener) } 代码比较长，这里以提取表名为例子
func (l *StmtListener) EnterTableName(ctx *TableNameContext) { var tableName string switch ctx.GetStop().GetTokenType() { // 需要去掉引号  case StmtParserREVERSE_QUOTE_ID, StmtParserCHARSET_REVERSE_QOUTE_STRING, StmtParserSTRING_LITERAL: name := ctx.GetStop().GetText() if len(name) &lt;= 2 { return } tableName = name[1 : len(name)-1] // db.tbl的形式  case StmtParserDOT_ID: name := ctx.GetStop().GetText() if len(name) &lt;= 1 { return } tableName = name[1:] default: tableName = ctx.GetText() } l.TableName = tableName } 除了解析之外，我们还需要对错误进行处理，不然错误发生我们都还不知道，无法判断SQL是否正确
type ErrorListener struct { *antlr.DefaultErrorListener errors []error } func NewErrorListener() *ErrorListener { return new(ErrorListener) } func (l *ErrorListener) HasError() bool { return len(l.errors) &gt; 0 } func (l *ErrorListener) Errors() []error { return l.errors } func (l *ErrorListener) SyntaxError(recognizer antlr.Recognizer, offendingSymbol interface{}, line, column int, msg string, e antlr.RecognitionException) { p := recognizer.(antlr.Parser) stack := p.GetRuleInvocationStack(p.GetParserRuleContext()) err := fmt.Errorf(&#34;rule: %v line %d: %d at %v : %s&#34;, stack[0], line, column, offendingSymbol, msg) l.errors = append(l.errors, err) } 随后便将上面两个集成在一起使用
import ( &#34;github.com/antlr/antlr4/runtime/Go/antlr/v4&#34; parser &#34;github.com/lemon-1997/sqlboy/antlr&#34; ) func parseStmt(ddl string) (parser.TableAttr, []error) { input := antlr.NewInputStream(ddl) lexer := parser.NewStmtLexer(input) stream := antlr.NewCommonTokenStream(lexer, 0) p := parser.NewStmtParser(stream) el := parser.NewErrorListener() p.RemoveErrorListeners() p.AddErrorListener(el) p.BuildParseTrees = true tree := p.Prog() if el.HasError() { return parser.TableAttr{}, el.Errors() } l := parser.NewStmtListener() antlr.ParseTreeWalkerDefault.Walk(l, tree) return l.TableAttr, nil } 在实现代码过程中，还发现了ANTLR go runtime包的一个错误，并提了个pr https://github.com/antlr/antlr4/pull/3999  
小结 好了，到这里我们已经能够正确把SQL解析，并提取出我们想要的表字段等信息，有了这些信息后，我们就可以根据表的结构，去生成相应的代码了。 下一节我将向大家介绍如果用模板渲染出代码，有兴趣的可以关注一下。
项目源码：https://github.com/lemon-1997/sqlboy
]]></content></entry><entry><title>go自动化生成数据库curd代码（二）：go抽象语法树（AST）</title><url>/post/project-sqlboy-2.html</url><categories><category>项目实战</category></categories><tags><tag>go</tag><tag>generate</tag><tag>sqlboy</tag><tag>AST</tag></tags><content type="html"><![CDATA[在上一篇文章中，介绍了我对这个项目的想法，总体设计与思路，而在项目中AST是一个很重要的模块，他主要负责输入的解析，还负责部分代码生成工作。 接下来，我将为大家介绍go中的抽象语法树，也会跟大家分享我是如何利用AST去实现功能的。
AST AST是go中的抽象语法树，许多代码生成工具，代码静态检测都离不开他。如果我们了解了AST，我们可以去实现一些好玩的东西。
go对节点的定义
// All node types implement the Node interface. type Node interface { Pos() token.Pos // position of first character belonging to the node 	End() token.Pos // position of first character immediately after the node } 主要有 3 类节点：Expr（表达式）, Stmt（语句）, Decl（声明）
// All expression nodes implement the Expr interface. type Expr interface { Node exprNode() } // All statement nodes implement the Stmt interface. type Stmt interface { Node stmtNode() } // All declaration nodes implement the Decl interface. type Decl interface { Node declNode() } 其中，我们着重要了解下Decl（声明节点），因为会经常用到，有三种Decl
// A declaration is represented by one of the following declaration nodes. type ( // A BadDecl node is a placeholder for a declaration containing 	// syntax errors for which a correct declaration node cannot be 	// created. 	// 	BadDecl struct { From, To token.Pos // position range of bad declaration 	} // A GenDecl node (generic declaration node) represents an import, 	// constant, type or variable declaration. A valid Lparen position 	// (Lparen.IsValid()) indicates a parenthesized declaration. 	// 	// Relationship between Tok value and Specs element type: 	// 	//	token.IMPORT *ImportSpec 	//	token.CONST *ValueSpec 	//	token.TYPE *TypeSpec 	//	token.VAR *ValueSpec 	// 	GenDecl struct { Doc *CommentGroup // associated documentation; or nil 	TokPos token.Pos // position of Tok 	Tok token.Token // IMPORT, CONST, TYPE, or VAR 	Lparen token.Pos // position of &#39;(&#39;, if any 	Specs []Spec Rparen token.Pos // position of &#39;)&#39;, if any 	} // A FuncDecl node represents a function declaration. 	FuncDecl struct { Doc *CommentGroup // associated documentation; or nil 	Recv *FieldList // receiver (methods); or nil (functions) 	Name *Ident // function/method name 	Type *FuncType // function signature: type and value parameters, results, and position of &#34;func&#34; keyword 	Body *BlockStmt // function body; or nil for external (non-Go) function 	} ) 通过注释我们可以大致得知，GenDecl用于表示import，const，type或变量声明，FunDecl用于表示函数声明。
那么，一个go文件会被抽象成什么样呢，下面是ast.File结构，后续也会经常用到
type File struct { Doc *CommentGroup // associated documentation; or nil 	Package token.Pos // position of &#34;package&#34; keyword 	Name *Ident // package name 	Decls []Decl // top-level declarations; or nil 	Scope *Scope // package scope (this file only) 	Imports []*ImportSpec // imports in this file 	Unresolved []*Ident // unresolved identifiers in this file 	Comments []*CommentGroup // list of all comments in the source file } 注释其实也解释的很清楚，有两个关键字段，一个是Name，用于我们提取包名，另外一个是Decls，const变量的声明。
有了该结构，思路也就来了，只要能拿到改结构体，事情就好办了，不过在开始写代码前，我们还要了解一下这个函数
func Inspect(node Node, f func(Node) bool) { Walk(inspector(f), node) } go官方怕我们对结构不熟悉，加上语法树层级复杂，嵌套的关系，这里贴心的帮我们实现了遍历的方法。 不过在这个项目我并没有用到，一个是我觉得遍历效率低，另一个是我的嵌套并不会很深，直接获取就行了。
处理输入 简单了解了AST后，我们就可以准备实现了。首先，我们定义我们的目标，一个是提取文件的包名，另一个是提取const变量以及对应的sql语句。 如何简单又快速的实现呢，这里推荐两种方法，一个是直接到 go AST viewer  网站上去看解析的结果，另一个是自己debug，将需要解析的文件AST抽象后看里面的结构。
假设我们有以下文件有解析
package sqlboy const ( order = ` -- order_info definition CREATE TABLE &#39;order_info&#39; ( &#39;id&#39; int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;自增ID&#39;, &#39;order_id&#39; varchar(20) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;订单号&#39;, &#39;status&#39; tinyint(3) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;订单状态&#39;, &#39;created_at&#39; timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;, &#39;updated_at&#39; timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;, PRIMARY KEY (&#39;id&#39;), UNIQUE KEY &#39;uk_order&#39; (&#39;order_id&#39;) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=&#39;订单表&#39;; ` ) 经过抽象后
0 *ast.File { 1 . Doc: nil 2 . Package: foo:1:1 3 . Name: *ast.Ident { 4 . . NamePos: foo:1:9 5 . . Name: &#34;sqlboy&#34; 6 . . Obj: nil 7 . } 8 . Decls: []ast.Decl (len = 1) { 9 . . 0: *ast.GenDecl { 10 . . . Doc: nil 11 . . . TokPos: foo:3:1 12 . . . Tok: const 13 . . . Lparen: foo:3:7 14 . . . Specs: []ast.Spec (len = 1) { 15 . . . . 0: *ast.ValueSpec { 16 . . . . . Doc: nil 17 . . . . . Names: []*ast.Ident (len = 1) { 18 . . . . . . 0: *ast.Ident { 19 . . . . . . . NamePos: foo:4:2 20 . . . . . . . Name: &#34;order&#34; 21 . . . . . . . Obj: *ast.Object { 22 . . . . . . . . Kind: const 23 . . . . . . . . Name: &#34;order&#34; 24 . . . . . . . . Decl: *(obj @ 15) 25 . . . . . . . . Data: 0 26 . . . . . . . . Type: nil 27 . . . . . . . } 28 . . . . . . } 29 . . . . . } 30 . . . . . Type: nil 31 . . . . . Values: []ast.Expr (len = 1) { 32 . . . . . . 0: *ast.BasicLit { 33 . . . . . . . ValuePos: foo:4:10 34 . . . . . . . Kind: STRING 35 . . . . . . . Value: &#34;`\n-- order_info definition\n\nCREATE TABLE &#39;order_info&#39; (\n &#39;id&#39; int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;自增ID&#39;,\n &#39;order_id&#39; varchar(20) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;订单号&#39;,\n &#39;status&#39; tinyint(3) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;订单状态&#39;,\n &#39;created_at&#39; timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,\n &#39;updated_at&#39; timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,\n PRIMARY KEY (&#39;id&#39;),\n UNIQUE KEY &#39;uk_order&#39; (&#39;order_id&#39;)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=&#39;订单表&#39;;\n`&#34; 36 . . . . . . } 37 . . . . . } 38 . . . . . Comment: nil 39 . . . . } 40 . . . } 41 . . . Rparen: foo:17:1 42 . . } 43 . } 44 . Scope: *ast.Scope { 45 . . Outer: nil 46 . . Objects: map[string]*ast.Object (len = 1) { 47 . . . &#34;order&#34;: *(obj @ 21) 48 . . } 49 . } 50 . Imports: nil 51 . Unresolved: nil 52 . Comments: nil 53 } 因此，我们可以写出以下解析代码
func parse(file *ast.File) (packageName string, ddl map[string]string) { if file == nil { return } if file.Name != nil { packageName = file.Name.Name } ddl = make(map[string]string) for _, decl := range file.Decls { genDecl, ok := decl.(*ast.GenDecl) if !ok { continue } if genDecl.Tok != token.CONST { continue } for _, spec := range genDecl.Specs { valueSpec, ok := spec.(*ast.ValueSpec) if !ok { continue } for i := range valueSpec.Names { value, ok := valueSpec.Values[i].(*ast.BasicLit) if !ok { continue } if value.Kind != token.STRING { continue } ddl[valueSpec.Names[i].Name] = value.Value } } } return } 这样一来，我们就实现了第一步对输入文件的解析，可能有的人会发现，上面的parse函数需要*ast.File结构，如何获得呢？
go已经帮我们实现好了，在$GOROOT/src/go/parser/interface.go
func ParseFile(fset *token.FileSet, filename string, src any, mode Mode) (f *ast.File, err error) 只需要提供文件路径，如果该文件没有语法错误的话，我们就能构建出*ast.File
编译时断言 在上一节说到，我们定义了输入的文件，建表的sql语句必须是const变量。这里我解释下，const主要是为了实现编译时断言。 什么是编译时断言呢，就是在编译时就能直接告诉你错误，无法编译通过。 许多自动化生成代码工具都会用到编译时断言，例如断言引用第三方库的版本，断言接口的实现，只要不符合，编译时就能及时发现，避免bug发生。
这里分享几个编译断言的技巧
 断言常量N不小于另一个常量M  func _(x []int) {_ = x[N-M]} func _(){_ = []int{N-M: 0}} func _([N-M]int){} var _ [N-M]int const _ uint = N-M type _ [N-M]int  断言两个整数常量相等  var _ [N-M]int; var _ [M-N]int type _ [N-M]int; type _ [M-N]int const _, _ uint = N-M, M-N func _([N-M]int, [M-N]int) {}  断言一个常量字符串是不是一个空串  type _ [len(aStringConstant)-1]int var _ = map[bool]int{false: 0, aStringConstant != &#34;&#34;: 1} var _ = aStringConstant[:1] var _ = aStringConstant[0] const _ = 1/len(aStringConstant)  断言字符串相等  const ( order = `order_info` product = `product_info` ) func _() { _ = map[bool]struct { }{false: {}, order == `order_info`: {}} _ = map[bool]struct { }{false: {}, product == `product_info`: {}} } 这个项目我用到了断言字符串相等，我保证了一旦建表语句sql被修改了，就必须重新生成断言文件，不然就无法编译通过。
确定了断言的方式之后，我们可以先看下断言文件对应的抽象语法树，然后再去编写代码，这里结构会复杂点，我就不放上来，直接贴实现的代码
func buildAssertAST(packageName string, paths, asserts map[string]string) *ast.File { importSpecs := make([]ast.Spec, 0) for name, path := range paths { importSpecs = append(importSpecs, &amp;ast.ImportSpec{ Name: ast.NewIdent(name), Path: &amp;ast.BasicLit{Kind: token.STRING, Value: path}, }) } maps := make([]*ast.CompositeLit, 0) for k, v := range asserts { elts := make([]ast.Expr, 0) elts = append(elts, &amp;ast.KeyValueExpr{ Key: ast.NewIdent(&#34;false&#34;), Value: &amp;ast.CompositeLit{}, }) elts = append(elts, &amp;ast.KeyValueExpr{ Key: &amp;ast.BinaryExpr{X: ast.NewIdent(k), Op: token.EQL, Y: &amp;ast.BasicLit{Kind: token.STRING, Value: v}}, Value: &amp;ast.CompositeLit{}, }) maps = append(maps, &amp;ast.CompositeLit{ Type: &amp;ast.MapType{Key: ast.NewIdent(&#34;bool&#34;), Value: &amp;ast.StructType{Fields: &amp;ast.FieldList{}}}, Elts: elts, }) } assignList := make([]ast.Stmt, 0) for _, item := range maps { assignList = append(assignList, &amp;ast.AssignStmt{ Lhs: []ast.Expr{ast.NewIdent(&#34;_&#34;)}, Tok: token.ASSIGN, Rhs: []ast.Expr{item}, }) } decls := make([]ast.Decl, 0) if len(paths) != 0 { decls = append(decls, &amp;ast.GenDecl{Tok: token.IMPORT, Specs: importSpecs}) } if len(asserts) != 0 { decls = append(decls, &amp;ast.FuncDecl{ Doc: &amp;ast.CommentGroup{List: []*ast.Comment{{Text: &#34;//compile-time assertion&#34;}}}, Name: ast.NewIdent(&#34;_&#34;), Type: &amp;ast.FuncType{}, Body: &amp;ast.BlockStmt{List: assignList}, }) } return &amp;ast.File{Name: ast.NewIdent(packageName), Decls: decls} } 到这里，我们不仅能解析用户的输入，还能构建出断言文件的抽象语法树。不过还差一步，就是将ast.File输出成.go文件。 当然，go也已经帮我们实现好了，在$GOROOT/src/go/format/format.go
func Node(dst io.Writer, fset *token.FileSet, node any) error 这里的参数是io.Writer，也就是你想输出到哪里都行，只要是实现了io.Writer的接口就行。
小结 到这里我们迈出了第一步，定义了输入的文件，并且通过AST将文件解析，提取出我们需要的东西，再将其生成编译时断言的文件。 不过这才刚刚开始，我们仅仅是实现了最简单的一部分，后面还有更难的要解决。下一篇文章是如何去实现对sql的解析，是关于ANTLR的，有兴趣的可以看一下。
项目源码：https://github.com/lemon-1997/sqlboy
]]></content></entry><entry><title>go自动化生成数据库curd代码（一）：想法与设计</title><url>/post/project-sqlboy.html</url><categories><category>项目实战</category></categories><tags><tag>go</tag><tag>generate</tag><tag>sqlboy</tag></tags><content type="html"><![CDATA[在平常业务开发中，我们经常会使用一些数据库框架，诸如gorm，sqlc，ent等等。 每当想新加一个表时，就会产生很多重复性的操作，例如插入数据，读取数据，删除之类。 这大大降低了开发效率，于是，我萌生了一个想法，想把这些操作都交给程序去实现。
想法 在有了这个想法之后，我根据实际业务需要，再结合一些优秀的开源项目后，我认为我的这个工具必须具备以下几个特点
 简单
一个是使用简单，代码生成的命令简单，没有复杂的参数，且输入只有sql建表语句。
另一个是生成的代码简单，可读，可靠，没有bug，尽量不生成冗余代码，使用者一目了然 。 全面
生成的代码要尽可能全面，覆盖到所有可能出现的场景。
本来我只想生成最基础的curd四个方法，后续又增加了批量插入，以及根据主键以及唯一键生成对于的查询，更新以及删除方法。 可用
可用的意思是即插即用，我生成的代码能立即被使用，无需做任何修改以及封装。
于是除了curd外，我还额外生成了dao，model，transaction等文件。  定义输入输出 输入 输入这里有两个选择，我纠结了好几天才做出的决定
 go文件：用go AST将建表sql读取解析。 配置文件：采用.yaml或者.json或者.sql的形式，然后读取配置文件。
利弊分析： 使用配置文件会比较优雅，好实现。 采用go ast读取实现较难，但是可以使用编译时断言。 最终为了学习下go AST，就不用简单的配置文件形式，而是采用后者。  输出 暂时决定有两种输出模式，一种是gorm，一种是sqlx，想生成哪种由用户决定。这里以sqlx为例，总共会生成以下文件：
 assert.go  package sqlboy func _() { _ = map[bool]struct { }{false: {}, order == ` -- order_info definition CREATE TABLE &#39;order_info&#39; ( &#39;id&#39; int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;自增ID&#39;, &#39;order_id&#39; varchar(20) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;订单号&#39;, &#39;status&#39; tinyint(3) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;订单状态&#39;, &#39;created_at&#39; timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;, &#39;updated_at&#39; timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;, PRIMARY KEY (&#39;id&#39;), UNIQUE KEY &#39;uk_order&#39; (&#39;order_id&#39;) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=&#39;订单表&#39;; `: {}} } model.go  package sqlboy import &#34;time&#34; type OrderInfo struct { Id uint32 `db:&#34;id&#34; json:&#34;id&#34;` //自增ID 	OrderId string `db:&#34;order_id&#34; json:&#34;order_id&#34;` //订单号 	Status int8 `db:&#34;status&#34; json:&#34;status&#34;` //订单状态 	CreatedAt time.Time `db:&#34;created_at&#34; json:&#34;created_at&#34;` //创建时间 	UpdatedAt time.Time `db:&#34;updated_at&#34; json:&#34;updated_at&#34;` //修改时间 } func (*OrderInfo) TableName() string { return `order_info` } dao.go  package sqlboy import ( &#34;context&#34; &#34;github.com/jmoiron/sqlx&#34; ) type contextTxKey struct{} type Dao struct { db *sqlx.DB } func NewDao(db *sqlx.DB) *Dao { return &amp;Dao{ db: db, } } func (d *Dao) InTx(ctx context.Context, fn func(ctx context.Context) error) error { tx, err := d.db.Begin() if err != nil { return err } defer func() { _ = tx.Rollback() }() err = fn(context.WithValue(ctx, contextTxKey{}, tx)) if err != nil { return err } return tx.Commit() } func (d *Dao) DB(ctx context.Context) DbTx { tx, ok := ctx.Value(contextTxKey{}).(*sqlx.Tx) if ok { return tx } return d.db } transaction.go  package sqlboy import ( &#34;context&#34; &#34;database/sql&#34; &#34;github.com/jmoiron/sqlx&#34; ) type Transaction interface { InTx(context.Context, func(ctx context.Context) error) error } func NewTransaction(d *Dao) Transaction { return d } type DbTx interface { QueryRowxContext(ctx context.Context, query string, args ...interface{}) *sqlx.Row QueryxContext(ctx context.Context, query string, args ...interface{}) (*sqlx.Rows, error) NamedExecContext(ctx context.Context, query string, arg interface{}) (sql.Result, error) ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error) } query_table.go (这个文件只展示一部分)  package sqlboy import &#34;context&#34; type OrderInfoDao interface { CreateOrderInfo(ctx context.Context, orderInfo *OrderInfo) error BatchCreateOrderInfo(ctx context.Context, list []*OrderInfo, batchSize int) error FindOrderInfo(ctx context.Context, id uint32) (*OrderInfo, error) UpdateOrderInfo(ctx context.Context, orderInfo *OrderInfo) error DeleteOrderInfo(ctx context.Context, id uint32) error FindByOrderId(ctx context.Context, orderId string) (*OrderInfo, error) UpdateByOrderId(ctx context.Context, orderInfo *OrderInfo) error DeleteByOrderId(ctx context.Context, orderId string) error } type OrderInfoImpl struct { dao *Dao } func NewOrderInfoDao(dao *Dao) OrderInfoDao { return &amp;OrderInfoImpl{ dao: dao, } } func (d *OrderInfoImpl) CreateOrderInfo(ctx context.Context, orderInfo *OrderInfo) error { _, err := d.dao.DB(ctx).NamedExecContext(ctx, &#34;INSERT INTO `order_info` (`id`,`order_id`,`status`,`created_at`,`updated_at`) VALUES (:id,:order_id,:status,:created_at,:updated_at)&#34;, orderInfo) return err } func (d *OrderInfoImpl) BatchCreateOrderInfo(ctx context.Context, list []*OrderInfo, batchSize int) error { return d.dao.InTx(ctx, func(ctx context.Context) error { for i := 0; i &lt; len(list); i += batchSize { ends := i + batchSize if ends &gt; len(list) { ends = len(list) } _, err := d.dao.DB(ctx).NamedExecContext(ctx, &#34;INSERT INTO `order_info` (`id`,`order_id`,`status`,`created_at`,`updated_at`) VALUES (:id,:order_id,:status,:created_at,:updated_at)&#34;, list[i:ends]) if err != nil { return err } } return nil }) } 设计  go AST
这个在前文有提到过，用来做输入的解析，建表语句的读取。这里我还把部分输出任务也给了他 （其实输出不应该用AST，效率低，且难以维护，这里只是为了尝试） ANTLR vs yacc
调研的时候发现很多ddl to struct的项目都是直接引用的一个使用yacc解析sql的库。 不过在经过对比之后，我发现yacc比较古老，而且还得自己去实现分词，因此直接放弃，采用更先进的ANTLR。 go template
输出是用的go原生text/template渲染，为了减少依赖，除了ANTLR，就没打算用第三方库。  整体架构 小结 这是sqlboy这个系列的第一篇文章，主要是写自己的想法由来，后续还将打算写四篇文章讲述具体实现细节。 这个项目已经完成了，欢迎大家使用并给我提bug。
项目源码 https://github.com/lemon-1997/sqlboy  
]]></content></entry><entry><title>如何在go中写好单元测试</title><url>/post/best-test.html</url><categories><category>最佳实践</category></categories><tags><tag>go</tag><tag>单元测试</tag></tags><content type="html"><![CDATA[当你还在用postman测试你的api时，那表明你还没找到使用go的最佳姿势，阅读这篇文章，一起来了解下go内置的测试框架，这会对你有所帮助。
单元测试 单元测试是我们项目开发中不可缺少的一部分，如果一个go项目没有单元测试，且刚好项目交接到你手里，由你来维护，那会很棘手，没有测试，意味着无法掌控这个项目，它就像一个定时炸弹，随时会产生bug。作为程序员，我们必须好好了解下单元测试。
单元测试基本概念  单元测试：应用中最小可测试部分，能够单独运行，用于被检测代码是否按照预期工作 测试用例：是一组测试，包括输入，执行条件，以及预期结果等 覆盖率：测试的度量，用来衡量代码被测试的比例 测试驱动开发：先有测试，后再通过修改代码使测试通过的开发方式  单元测试的优点  易于调试 提前发现问题 短代码，简洁且高质量  可能有人会觉得写单元测试是一件很麻烦的事，认为浪费时间。但也许你写了单元测试，他能减少你项目出问题排错的时间，也能让你更好的运行指定的代码，更精准的找到问题。写单元测试其实为你带来了效率上的提升，并且在go中，为项目增加单元测试非常简单。
go内置测试框架 go官方包自带了测试框架，这不仅仅是go官方为了所有gopher能更方便的写测试，也直接证明了测试的重要性，官方直接把他丢进了std里，可见一斑。 在最新版本的go中，go团队加入了模糊测试，不过本篇文章只涉及单元测试，不会讲解基准测试以及模糊测试。
testing.T 在go中写单元测试，我们先写了解下 testing.T 这个类型以及其持有的方法
// TB is the interface common to T and B. type TB interface { Cleanup(func()) Error(args ...interface{}) Errorf(format string, args ...interface{}) Fail() FailNow() Failed() bool Fatal(args ...interface{}) Fatalf(format string, args ...interface{}) Helper() Log(args ...interface{}) Logf(format string, args ...interface{}) Name() string Skip(args ...interface{}) SkipNow() Skipf(format string, args ...interface{}) Skipped() bool TempDir() string // A private method to prevent users implementing the  // interface and so future additions to it will not  // violate Go 1 compatibility.  private() } type T struct { common isParallel bool context *testContext // For running tests and subtests. } var _ TB = (*T)(nil) 这里顺便给大家科普下，var _ TB = (*T)(nil) 这行语句，使用了编译时断言，如果 T 没有实现 TB 里定义的方法，那么编译就会报错，这样能让开发者及时发现问题，避免错误的发生。大家平常写代码也可以使用编译时断言来让自己的项目更加健壮。
常用方法
 Logf：记录日志，提供代码测试时运行信息 Errorf：记录日志，但会让测试不能通过 Fatalf：记录日志，测试立即停止且测试失败 Skipf：记录日志，并跳过该测试函数 Cleanup：清理函数，资源的释放 Helper：辅助函数，打印文件行信息  官方例子 testing.T 看起来比较简单，老规矩，先上官方例子
package greetings import ( &#34;testing&#34; &#34;regexp&#34; ) // TestHelloName calls greetings.Hello with a name, checking // for a valid return value. func TestHelloName(t *testing.T) { name := &#34;Gladys&#34; want := regexp.MustCompile(`\b`+name+`\b`) msg, err := Hello(&#34;Gladys&#34;) if !want.MatchString(msg) || err != nil { t.Fatalf(`Hello(&#34;Gladys&#34;) = %q, %v, want match for %#q, nil`, msg, err, want) } } // TestHelloEmpty calls greetings.Hello with an empty string, // checking for an error. func TestHelloEmpty(t *testing.T) { msg, err := Hello(&#34;&#34;) if msg != &#34;&#34; || err == nil { t.Fatalf(`Hello(&#34;&#34;) = %q, %v, want &#34;&#34;, error`, msg, err) } } 上面的例子大家应该都看得懂，我就不总结具体的测试流程了，这里主要是为了给大家展示在go中写单元测试是多么方便。
最佳实践 starting 在开始之前，我们要先了解go的测试规范
 文件名：前缀为测试代码的文件名，以 _test.go 结尾（go build 会忽略这些文件） 文件位置：位于测试的代码同一 package 下 函数名：Test 为前缀，后面是测试函数名，函数参数为 *testing.T  table test table test 是一种很棒的写法，它能让你的测试代码足够清晰，让你的测试用例易于维护，该写法可以在各种库中见到。其大体流程为：
 定义tests 为测试用例，其结构为匿名结构体切片 []struct{} 补充匿名结构体变量，定义好输入输出，丰富测试用例 遍历测试用例，调用测试方法，判断测试结果是否符合预期 使用 testing.T 里的方法记录日志或让测试失败  go源码 encoding/json/encode_test.go 里就采用了这种测试方式
func TestRoundtripStringTag(t *testing.T) { tests := []struct { name string in StringTag want string // empty to just test that we roundtrip 	}{ { name: &#34;AllTypes&#34;, in: StringTag{ BoolStr: true, IntStr: 42, UintptrStr: 44, StrStr: &#34;xzbit&#34;, NumberStr: &#34;46&#34;, }, want: `{ &#34;BoolStr&#34;: &#34;true&#34;, &#34;IntStr&#34;: &#34;42&#34;, &#34;UintptrStr&#34;: &#34;44&#34;, &#34;StrStr&#34;: &#34;\&#34;xzbit\&#34;&#34;, &#34;NumberStr&#34;: &#34;46&#34; }`, }, { // See golang.org/issues/38173. 	name: &#34;StringDoubleEscapes&#34;, in: StringTag{ StrStr: &#34;\b\f\n\r\t\&#34;\\&#34;, NumberStr: &#34;0&#34;, // just to satisfy the roundtrip 	}, want: `{ &#34;BoolStr&#34;: &#34;false&#34;, &#34;IntStr&#34;: &#34;0&#34;, &#34;UintptrStr&#34;: &#34;0&#34;, &#34;StrStr&#34;: &#34;\&#34;\\u0008\\u000c\\n\\r\\t\\\&#34;\\\\\&#34;&#34;, &#34;NumberStr&#34;: &#34;0&#34; }`, }, } for _, test := range tests { t.Run(test.name, func(t *testing.T) { // Indent with a tab prefix to make the multi-line string 	// literals in the table nicer to read. 	got, err := MarshalIndent(&amp;test.in, &#34;\t\t\t&#34;, &#34;\t&#34;) if err != nil { t.Fatal(err) } if got := string(got); got != test.want { t.Fatalf(&#34; got: %s\nwant: %s\n&#34;, got, test.want) } // Verify that it round-trips. 	var s2 StringTag if err := Unmarshal(got, &amp;s2); err != nil { t.Fatalf(&#34;Decode: %v&#34;, err) } if !reflect.DeepEqual(test.in, s2) { t.Fatalf(&#34;decode didn&#39;t match.\nsource: %#v\nEncoded as:\n%s\ndecode: %#v&#34;, test.in, string(got), s2) } }) } } mock test 当我们由于某些原因，不好直接调用我们的函数去做测试时，我们应该如何做呢？答案就是 interface ，如果我们的测试函数输入刚好是 interface 时，那很棒，如果不是呢，考虑下将函数参数抽象为 interfae ，是否你的代码会更好。
直接看下面的例子，这也是来自go源码 io/io_test.go
type zeroErrReader struct { err error } func (r zeroErrReader) Read(p []byte) (int, error) { return copy(p, []byte{0}), r.err } type errWriter struct { err error } func (w errWriter) Write([]byte) (int, error) { return 0, w.err } // In case a Read results in an error with non-zero bytes read, and // the subsequent Write also results in an error, the error from Write // is returned, as it is the one that prevented progressing further. func TestCopyReadErrWriteErr(t *testing.T) { er, ew := errors.New(&#34;readError&#34;), errors.New(&#34;writeError&#34;) r, w := zeroErrReader{err: er}, errWriter{err: ew} n, err := Copy(w, r) if n != 0 || err != ew { t.Errorf(&#34;Copy(zeroErrReader, errWriter) = %d, %v; want 0, writeError&#34;, n, err) } } 这里通过 zeroErrReader 和 errWriter mock数据，分别实现了 io.Reader 以及 io.Writer ，当我们写测试时，具体怎样mock取决于你想测试的东西。
dependency injection 有些时候，我们的测试需要外部依赖，例如我们需要数据库实例或者http server，这时候我们可以利用 TestMain 的特性
来看看go源码 net/http/main_test.go
func TestMain(m *testing.M) { setupTestData() installTestHooks() st := m.Run() testHookUninstaller.Do(uninstallTestHooks) if testing.Verbose() { printRunningGoroutines() printInflightSockets() printSocketStats() } forceCloseSockets() os.Exit(st) } 执行测试的时候，会优先执行 TestMain ，然后再通过 m.Run() 执行其他的测试，最好释放我们的资源，这样就解决了我们的资源依赖问题。这里给出一个模板参考，具体的 setup() 和 teardown() 的实现由自己的项目代码所决定。
func setup() { fmt.Printf(&#34;Setup&#34;) } func teardown() { fmt.Printf(&#34;Teardown&#34;) } func TestMain(m *testing.M) { setup() code := m.Run() teardown() os.Exit(code) } 结语 这篇文章所讲的东西都是自己最近写单元测试的一些感悟，如果有错误可在下方评论指出，如果对你有帮助，我也很希望在评论区看到你的评论。 好了，到这里就结束了，感谢阅读！
]]></content></entry><entry><title>mysql事务在go语言中的正确打开方式</title><url>/post/best-transaction.html</url><categories><category>最佳实践</category></categories><tags><tag>go</tag><tag>mysql</tag></tags><content type="html"><![CDATA[相信大家在做curd项目时经常会使用到mysql中的事务，这篇文章将会展示在go中实现mysql事务的几种方式，希望阅读后能够给你带来启发。
mysql事务 mysql的事务保证了我们应用程序和业务逻辑的可靠，是我们日常开发重要的一环，我们必须了解其特性，才能更好的使用它。
ACID模型 首先介绍下 ACID 模型
 A：原子性。事务中的操作要么 commit 成功，要么全部 rollback C：一致性。事务的执行前后数据要一致，主要是保护数据丢失，比如 innodb 中的崩溃恢复机制 I：隔离性。事务内部的操作与其他事务的隔离，比如隔离级别以及锁机制 D：持久性。事务提交后对数据库具有永久性  使用场景 上面的ACID其实已经可以体现出事务的使用场景。举几个例子
 用户下单时，需要在订单表创建一条记录，并扣减商品的库存 转账时，一方扣款，另一方必须增加对应的金额 查询到其他事务还没有提交的数据，导致脏读  了解了什么是事务，接下来我们一起看下在go中是怎么开启事务。
go实现方式 go开启事务的几个步骤
 开启事务 执行数据库操作 结束事务  提交事务 回滚事务    看起来很简单，就三个步骤而已，下面看下具体的代码实例。
go官方例子 先欣赏下go官方提供的例子
// CreateOrder creates an order for an album and returns the new order ID. func CreateOrder(ctx context.Context, albumID, quantity, custID int) (orderID int64, err error) { // Create a helper function for preparing failure results.  fail := func(err error) (int64, error) { return fmt.Errorf(&#34;CreateOrder: %v&#34;, err) } // Get a Tx for making transaction requests.  tx, err := db.BeginTx(ctx, nil) if err != nil { return fail(err) } // Defer a rollback in case anything fails.  defer tx.Rollback() // Confirm that album inventory is enough for the order.  var enough bool if err = tx.QueryRowContext(ctx, &#34;SELECT (quantity &gt;= ?) from album where id = ?&#34;, quantity, albumID).Scan(&amp;enough); err != nil { if err == sql.ErrNoRows { return fail(fmt.Errorf(&#34;no such album&#34;)) } return fail(err) } if !enough { return fail(fmt.Errorf(&#34;not enough inventory&#34;)) } // Update the album inventory to remove the quantity in the order.  _, err = tx.ExecContext(ctx, &#34;UPDATE album SET quantity = quantity - ? WHERE id = ?&#34;, quantity, albumID) if err != nil { return fail(err) } // Create a new row in the album_order table.  result, err := tx.ExecContext(ctx, &#34;INSERT INTO album_order (album_id, cust_id, quantity, date) VALUES (?, ?, ?, ?)&#34;, albumID, custID, quantity, time.Now()) if err != nil { return fail(err) } // Get the ID of the order item just created.  orderID, err := result.LastInsertId() if err != nil { return fail(err) } // Commit the transaction.  if err = tx.Commit(); err != nil { return fail(err) } // Return the order ID.  return orderID, nil } 这是go官方提供的例子，大体的代码流程如下
 通过 DB.Begin / DB.BeginTx 获取 sql.Tx 延迟调用 Tx.Rollback 执行数据库的插入修改语句 没有出错，通过 Tx.Commit 提交  这种方式看起来很不错，失败了能回滚，成功则一起提交，很清晰的表明事务的整个流程。 但是当你项目的业务逻辑愈加复杂，或者事务里面的某个表新加了字段，需要去调整SQL语句的时候，你必须在这个大函数里面去修改，这看起来很危险。 像这个例子所体现的，该函数里面做了多个SQL操作，除了单一的业务场景，很难被别的地方复用。
mysql事务封装 于是，针对上面的问题，可以先将事务的操作封装起来，并抽离出数据库执行SQL的函数 fn
func WithTransaction(db *sql.DB, fn func(sql.Tx) error) (err error) { tx, err := db.Begin() if err != nil { return } defer func() { if p := recover(); p != nil { // a panic occurred, rollback and repanic 	tx.Rollback() panic(p) } else if err != nil { // something went wrong, rollback 	tx.Rollback() } else { // all good, commit 	err = tx.Commit() } }() err = fn(tx) return err } 因此使用起来只需要编写相应的数据库操作函数 fn，我们可以对订单，商品数据的操作做更细粒度的封装，就像下面这样
err = WithTransaction(db, func(tx sql.Tx) error { // insert a record into order table 	res, err := dao.CreateOrder(tx,order) if err != nil { return err } // update product inventory 	res, err = dao.UpdateInventory(tx,product) if err != nil { return err } }) 好了，目前看来这个例子已经很完美了，我们不需要写过多的重复代码，事务的操作，数据库执行的SQL都能被很好的复用。 但是还有个问题，上面的 CreateOrder 和 UpdateInventory 函数需要传入 sql.Tx，这会使调用者难以下手，理论上调用者不应该关心传入哪个数据库，他只想完成创建订单，扣减库存的操作。 而且，当你的事务只需要执行一次SQL时，并不需要开启事务的，但你的传参确实 sql.Tx，这会导致多余的代码，且很不优雅。
interface登场 假设我们现在有一个数据库操作对象 Dao
type Dao struct{ db *sql.Db } func (d *Dao ) CreateOrder(ctx context, order entity.Order) error { d.db.ExecContext(ctx, `Insert into`, order) } func (d *Dao ) UpdateInventory(ctx context, product entity.Product) error { d.db.ExecContext(ctx, `Insert into`, product) } 如果我们现在需要开启一个事务，这个事务里需要执行 CreateOrder 和 UpdateInventory，这个时候，很多人的第一个想法是重新写一个函数，因为现有的函数都是由 sql.Db 去执行，而不是 sql.Tx。 那我们有没有办法减少重复代码的开发呢？答案是有的，那就是 interface{}
// Queries is a common interface that is used by both *sqlx.DB and *sqlx.Tx. type Queries interface { QueryRowxContext(ctx context.Context, query string, args ...interface{}) *sqlx.Row QueryxContext(ctx context.Context, query string, args ...interface{}) (*sqlx.Rows, error) NamedExecContext(ctx context.Context, query string, arg interface{}) (sql.Result, error) ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error) } 在这里，我们定义了一个叫 Queries 的 interface 去实现 sql.Db 和 sql.Tx 。那么再对 Dao 重新调整一下，并对外提供一个 New 函数，支持传入 sql.Db 和 sql.Tx
type Dao struct{ db Queries } fun NewOderDao (db Queries) *Dao{ return &amp;oderDao{db:db} } 这样一来，我们通过 Queries 使 Dao 中的函数可以同时是普通执行或者开启事务执行，且调用相关函数时不需要传入数据库对象。那么问题来了，如何与上面封装好的 WithTransaction一起使用呢？
best practices 上面的 WithTransaction 函数注入了 sql.Tx，那么，我们可以将两者结合，改变一下注入对象，将 Dao 注入给 fn
func WithTransaction(db *sql.DB, fn func(dao *Dao) error) (err error) { tx, err := db.Beginx() if err != nil { return } defer func() { if p := recover(); p != nil { // a panic occurred, rollback and repanic 	tx.Rollback() panic(p) } else if err != nil { // something went wrong, rollback 	tx.Rollback() } else { // all good, commit 	err = tx.Commit() } }() // inject 	dao := NewOderDao(tx) err = fn(dao) return err } 这样一来，调用 WithTransaction 就可以拿到数据库操作对象了。最后别忘了补充单元测试，那是你go项目中可靠性以及可维护性的一部分
// init db dao func init(){ } func Test_WithTransaction(t *testing.T) { tests := []struct{ fn func(dao *Dao)error // out? or else  }{ { func(dao *Dao)error{ ctx, cancel := context.WithCancel(context.Background()) cancel() err := dao.CreateOrderInfo(ctx, &amp;order) if err != nil { t.Logf(&#34;error %v emit roollback&#34;, err) return err } t.Logf(&#34;comit order %v&#34;, order) return nil }, }, { func(dao *Dao)error{ return nil }, }, } for _, tt := range tests{ _ = WithTransaction(db, tt.fn) } } 结语 关于mysql的事务操作，相信还有更优秀的写法，这篇文章的例子也许不是最好的，但希望能给你带来启发，有兴趣的可以在下方评论与我交流。
]]></content></entry><entry><title>后端开发必备的工具及网站</title><url>/post/other-develop.html</url><categories><category>随想记录</category></categories><tags><tag>后端</tag></tags><content type="html">other-develop</content></entry><entry><title>Kratos的设计哲学</title><url>/post/frame-kratos.html</url><categories><category>框架教程</category></categories><tags><tag>go</tag><tag>kratos</tag></tags><content type="html">frame-kratos</content></entry><entry><title>go上下文Context包源码分析</title><url>/post/source-context.html</url><categories><category>源码分析</category></categories><tags><tag>go</tag><tag>context</tag></tags><content type="html">source-context</content></entry><entry><title>lemon</title><url>/about/</url><categories/><tags><tag>lemon</tag></tags><content type="html">大家好，我是lemon，目前在深圳从事互联网相关的工作。从事后端开发已经有几年时间了，主要使用的语言是go，平常喜欢去研究go，一直致力于写出更优雅的go代码。建立此博客的初衷一是为了分享给其他人，二是自己分享了，也会去总结，自己能够有所收获。
博客专题 最佳实践 源码分析 项目实战 框架教程 随想记录 博客地址 国内： https://lemon-1997.pages.dev/ 国外： https://lemon-1997.github.io/ 联系方式 Github： https://github.com/lemon-1997 邮箱：lemom_ 1997@126.com 评论：参与下方评论与我交流</content></entry></search>