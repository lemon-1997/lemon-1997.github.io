<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>go自动化生成数据库curd代码（二）：go抽象语法树（AST）</title><url>/post/project-sqlboy-2.html</url><categories><category>项目实战</category></categories><tags><tag>go</tag><tag>generate</tag><tag>sqlboy</tag><tag>AST</tag></tags><content type="html"><![CDATA[在上一篇文章中，介绍了我对这个项目的想法，总体设计与思路，而在项目中AST是一个很重要的模块，他主要负责输入的解析，还负责部分代码生成工作。 接下来，我将为大家介绍go中的抽象语法树，也会跟大家分享我是如何利用AST去实现功能的。
AST AST是go中的抽象语法树，许多代码生成工具，代码静态检测都离不开他。如果我们了解了AST，我们可以去实现一些好玩的东西。
go对节点的定义
// All node types implement the Node interface. type Node interface { Pos() token.Pos // position of first character belonging to the node 	End() token.Pos // position of first character immediately after the node } 主要有 3 类节点：Expr（表达式）, Stmt（语句）, Decl（声明）
// All expression nodes implement the Expr interface. type Expr interface { Node exprNode() } // All statement nodes implement the Stmt interface. type Stmt interface { Node stmtNode() } // All declaration nodes implement the Decl interface. type Decl interface { Node declNode() } 其中，我们着重要了解下Decl（声明节点），因为会经常用到，有三种Decl
// A declaration is represented by one of the following declaration nodes. type ( // A BadDecl node is a placeholder for a declaration containing 	// syntax errors for which a correct declaration node cannot be 	// created. 	// 	BadDecl struct { From, To token.Pos // position range of bad declaration 	} // A GenDecl node (generic declaration node) represents an import, 	// constant, type or variable declaration. A valid Lparen position 	// (Lparen.IsValid()) indicates a parenthesized declaration. 	// 	// Relationship between Tok value and Specs element type: 	// 	//	token.IMPORT *ImportSpec 	//	token.CONST *ValueSpec 	//	token.TYPE *TypeSpec 	//	token.VAR *ValueSpec 	// 	GenDecl struct { Doc *CommentGroup // associated documentation; or nil 	TokPos token.Pos // position of Tok 	Tok token.Token // IMPORT, CONST, TYPE, or VAR 	Lparen token.Pos // position of &#39;(&#39;, if any 	Specs []Spec Rparen token.Pos // position of &#39;)&#39;, if any 	} // A FuncDecl node represents a function declaration. 	FuncDecl struct { Doc *CommentGroup // associated documentation; or nil 	Recv *FieldList // receiver (methods); or nil (functions) 	Name *Ident // function/method name 	Type *FuncType // function signature: type and value parameters, results, and position of &#34;func&#34; keyword 	Body *BlockStmt // function body; or nil for external (non-Go) function 	} ) 通过注释我们可以大致得知，GenDecl用于表示import，const，type或变量声明，FunDecl用于表示函数声明。
那么，一个go文件会被抽象成什么样呢，下面是ast.File结构，后续也会经常用到
type File struct { Doc *CommentGroup // associated documentation; or nil 	Package token.Pos // position of &#34;package&#34; keyword 	Name *Ident // package name 	Decls []Decl // top-level declarations; or nil 	Scope *Scope // package scope (this file only) 	Imports []*ImportSpec // imports in this file 	Unresolved []*Ident // unresolved identifiers in this file 	Comments []*CommentGroup // list of all comments in the source file } 注释其实也解释的很清楚，有两个关键字段，一个是Name，用于我们提取包名，另外一个是Decls，const变量的声明。
有了该结构，思路也就来了，只要能拿到改结构体，事情就好办了，不过在开始写代码前，我们还要了解一下这个函数
func Inspect(node Node, f func(Node) bool) { Walk(inspector(f), node) } go官方怕我们对结构不熟悉，加上语法树层级复杂，嵌套的关系，这里贴心的帮我们实现了遍历的方法。 不过在这个项目我并没有用到，一个是我觉得遍历效率低，另一个是我的嵌套并不会很深，直接获取就行了。
处理输入 简单了解了AST后，我们就可以准备实现了。首先，我们定义我们的目标，一个是提取文件的包名，另一个是提取const变量以及对应的sql语句。 如何简单又快速的实现呢，这里推荐两种方法，一个是直接到 go AST viewer  网站上去看解析的结果，另一个是自己debug，将需要解析的文件AST抽象后看里面的结构。
假设我们有以下文件有解析
package sqlboy const ( order = ` -- order_info definition CREATE TABLE &#39;order_info&#39; ( &#39;id&#39; int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;自增ID&#39;, &#39;order_id&#39; varchar(20) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;订单号&#39;, &#39;status&#39; tinyint(3) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;订单状态&#39;, &#39;created_at&#39; timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;, &#39;updated_at&#39; timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;, PRIMARY KEY (&#39;id&#39;), UNIQUE KEY &#39;uk_order&#39; (&#39;order_id&#39;) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=&#39;订单表&#39;; ` ) 经过抽象后
0 *ast.File { 1 . Doc: nil 2 . Package: foo:1:1 3 . Name: *ast.Ident { 4 . . NamePos: foo:1:9 5 . . Name: &#34;sqlboy&#34; 6 . . Obj: nil 7 . } 8 . Decls: []ast.Decl (len = 1) { 9 . . 0: *ast.GenDecl { 10 . . . Doc: nil 11 . . . TokPos: foo:3:1 12 . . . Tok: const 13 . . . Lparen: foo:3:7 14 . . . Specs: []ast.Spec (len = 1) { 15 . . . . 0: *ast.ValueSpec { 16 . . . . . Doc: nil 17 . . . . . Names: []*ast.Ident (len = 1) { 18 . . . . . . 0: *ast.Ident { 19 . . . . . . . NamePos: foo:4:2 20 . . . . . . . Name: &#34;order&#34; 21 . . . . . . . Obj: *ast.Object { 22 . . . . . . . . Kind: const 23 . . . . . . . . Name: &#34;order&#34; 24 . . . . . . . . Decl: *(obj @ 15) 25 . . . . . . . . Data: 0 26 . . . . . . . . Type: nil 27 . . . . . . . } 28 . . . . . . } 29 . . . . . } 30 . . . . . Type: nil 31 . . . . . Values: []ast.Expr (len = 1) { 32 . . . . . . 0: *ast.BasicLit { 33 . . . . . . . ValuePos: foo:4:10 34 . . . . . . . Kind: STRING 35 . . . . . . . Value: &#34;`\n-- order_info definition\n\nCREATE TABLE &#39;order_info&#39; (\n &#39;id&#39; int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;自增ID&#39;,\n &#39;order_id&#39; varchar(20) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;订单号&#39;,\n &#39;status&#39; tinyint(3) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;订单状态&#39;,\n &#39;created_at&#39; timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,\n &#39;updated_at&#39; timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,\n PRIMARY KEY (&#39;id&#39;),\n UNIQUE KEY &#39;uk_order&#39; (&#39;order_id&#39;)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=&#39;订单表&#39;;\n`&#34; 36 . . . . . . } 37 . . . . . } 38 . . . . . Comment: nil 39 . . . . } 40 . . . } 41 . . . Rparen: foo:17:1 42 . . } 43 . } 44 . Scope: *ast.Scope { 45 . . Outer: nil 46 . . Objects: map[string]*ast.Object (len = 1) { 47 . . . &#34;order&#34;: *(obj @ 21) 48 . . } 49 . } 50 . Imports: nil 51 . Unresolved: nil 52 . Comments: nil 53 } 因此，我们可以写出以下解析代码
func parse(file *ast.File) (packageName string, ddl map[string]string) { if file == nil { return } if file.Name != nil { packageName = file.Name.Name } ddl = make(map[string]string) for _, decl := range file.Decls { genDecl, ok := decl.(*ast.GenDecl) if !ok { continue } if genDecl.Tok != token.CONST { continue } for _, spec := range genDecl.Specs { valueSpec, ok := spec.(*ast.ValueSpec) if !ok { continue } for i := range valueSpec.Names { value, ok := valueSpec.Values[i].(*ast.BasicLit) if !ok { continue } if value.Kind != token.STRING { continue } ddl[valueSpec.Names[i].Name] = value.Value } } } return } 这样一来，我们就实现了第一步对输入文件的解析，可能有的人会发现，上面的parse函数需要*ast.File结构，如何获得呢？
go已经帮我们实现好了，在$GOROOT/src/go/parser/interface.go
func ParseFile(fset *token.FileSet, filename string, src any, mode Mode) (f *ast.File, err error) 只需要提供文件路径，如果该文件没有语法错误的话，我们就能构建出*ast.File
编译时断言 在上一节说到，我们定义了输入的文件，建表的sql语句必须是const变量。这里我解释下，const主要是为了实现编译时断言。 什么是编译时断言呢，就是在编译时就能直接告诉你错误，无法编译通过。 许多自动化生成代码工具都会用到编译时断言，例如断言引用第三方库的版本，断言接口的实现，只要不符合，编译时就能及时发现，避免bug发生。
这里分享几个编译断言的技巧
 断言常量N不小于另一个常量M  func _(x []int) {_ = x[N-M]} func _(){_ = []int{N-M: 0}} func _([N-M]int){} var _ [N-M]int const _ uint = N-M type _ [N-M]int  断言两个整数常量相等  var _ [N-M]int; var _ [M-N]int type _ [N-M]int; type _ [M-N]int const _, _ uint = N-M, M-N func _([N-M]int, [M-N]int) {}  断言一个常量字符串是不是一个空串  type _ [len(aStringConstant)-1]int var _ = map[bool]int{false: 0, aStringConstant != &#34;&#34;: 1} var _ = aStringConstant[:1] var _ = aStringConstant[0] const _ = 1/len(aStringConstant)  断言字符串相等  const ( order = `order_info` product = `product_info` ) func _() { _ = map[bool]struct { }{false: {}, order == `order_info`: {}} _ = map[bool]struct { }{false: {}, product == `product_info`: {}} } 这个项目我用到了断言字符串相等，我保证了一旦建表语句sql被修改了，就必须重新生成断言文件，不然就无法编译通过。
确定了断言的方式之后，我们可以先看下断言文件对应的抽象语法树，然后再去编写代码，这里结构会复杂点，我就不放上来，直接贴实现的代码
func buildAssertAST(packageName string, paths, asserts map[string]string) *ast.File { importSpecs := make([]ast.Spec, 0) for name, path := range paths { importSpecs = append(importSpecs, &amp;ast.ImportSpec{ Name: ast.NewIdent(name), Path: &amp;ast.BasicLit{Kind: token.STRING, Value: path}, }) } maps := make([]*ast.CompositeLit, 0) for k, v := range asserts { elts := make([]ast.Expr, 0) elts = append(elts, &amp;ast.KeyValueExpr{ Key: ast.NewIdent(&#34;false&#34;), Value: &amp;ast.CompositeLit{}, }) elts = append(elts, &amp;ast.KeyValueExpr{ Key: &amp;ast.BinaryExpr{X: ast.NewIdent(k), Op: token.EQL, Y: &amp;ast.BasicLit{Kind: token.STRING, Value: v}}, Value: &amp;ast.CompositeLit{}, }) maps = append(maps, &amp;ast.CompositeLit{ Type: &amp;ast.MapType{Key: ast.NewIdent(&#34;bool&#34;), Value: &amp;ast.StructType{Fields: &amp;ast.FieldList{}}}, Elts: elts, }) } assignList := make([]ast.Stmt, 0) for _, item := range maps { assignList = append(assignList, &amp;ast.AssignStmt{ Lhs: []ast.Expr{ast.NewIdent(&#34;_&#34;)}, Tok: token.ASSIGN, Rhs: []ast.Expr{item}, }) } decls := make([]ast.Decl, 0) if len(paths) != 0 { decls = append(decls, &amp;ast.GenDecl{Tok: token.IMPORT, Specs: importSpecs}) } if len(asserts) != 0 { decls = append(decls, &amp;ast.FuncDecl{ Doc: &amp;ast.CommentGroup{List: []*ast.Comment{{Text: &#34;//compile-time assertion&#34;}}}, Name: ast.NewIdent(&#34;_&#34;), Type: &amp;ast.FuncType{}, Body: &amp;ast.BlockStmt{List: assignList}, }) } return &amp;ast.File{Name: ast.NewIdent(packageName), Decls: decls} } 到这里，我们不仅能解析用户的输入，还能构建出断言文件的抽象语法树。不过还差一步，就是将ast.File输出成.go文件。 当然，go也已经帮我们实现好了，在$GOROOT/src/go/format/format.go
func Node(dst io.Writer, fset *token.FileSet, node any) error 这里的参数是io.Writer，也就是你想输出到哪里都行，只要是实现了io.Writer的接口就行。
小结 到这里我们迈出了第一步，定义了输入的文件，并且通过AST将文件解析，提取出我们需要的东西，再将其生成编译时断言的文件。 不过这才刚刚开始，我们仅仅是实现了最简单的一部分，后面还有更难的要解决。下一篇文章是如何去实现对sql的解析，是关于ANTLR的，有兴趣的可以看一下。
项目源码：https://github.com/lemon-1997/sqlboy
]]></content></entry><entry><title>go自动化生成数据库curd代码（一）：想法与设计</title><url>/post/project-sqlboy.html</url><categories><category>项目实战</category></categories><tags><tag>go</tag><tag>generate</tag><tag>sqlboy</tag></tags><content type="html"><![CDATA[在平常业务开发中，我们经常会使用一些数据库框架，诸如gorm，sqlc，ent等等。 每当想新加一个表时，就会产生很多重复性的操作，例如插入数据，读取数据，删除之类。 这大大降低了开发效率，于是，我萌生了一个想法，想把这些操作都交给程序去实现。
想法 在有了这个想法之后，我根据实际业务需要，再结合一些优秀的开源项目后，我认为我的这个工具必须具备以下几个特点
 简单
一个是使用简单，代码生成的命令简单，没有复杂的参数，且输入只有sql建表语句。
另一个是生成的代码简单，可读，可靠，没有bug，尽量不生成冗余代码，使用者一目了然 。 全面
生成的代码要尽可能全面，覆盖到所有可能出现的场景。
本来我只想生成最基础的curd四个方法，后续又增加了批量插入，以及根据主键以及唯一键生成对于的查询，更新以及删除方法。 可用
可用的意思是即插即用，我生成的代码能立即被使用，无需做任何修改以及封装。
于是除了curd外，我还额外生成了dao，model，transaction等文件。  定义输入输出 输入 输入这里有两个选择，我纠结了好几天才做出的决定
 go文件：用go AST将建表sql读取解析。 配置文件：采用.yaml或者.json或者.sql的形式，然后读取配置文件。
利弊分析： 使用配置文件会比较优雅，好实现。 采用go ast读取实现较难，但是可以使用编译时断言。 最终为了学习下go AST，就不用简单的配置文件形式，而是采用后者。  输出 暂时决定有两种输出模式，一种是gorm，一种是sqlx，想生成哪种由用户决定。这里以sqlx为例，总共会生成以下文件：
 assert.go  package sqlboy func _() { _ = map[bool]struct { }{false: {}, order == ` -- order_info definition CREATE TABLE &#39;order_info&#39; ( &#39;id&#39; int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;自增ID&#39;, &#39;order_id&#39; varchar(20) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;订单号&#39;, &#39;status&#39; tinyint(3) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;订单状态&#39;, &#39;created_at&#39; timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;, &#39;updated_at&#39; timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;, PRIMARY KEY (&#39;id&#39;), UNIQUE KEY &#39;uk_order&#39; (&#39;order_id&#39;) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=&#39;订单表&#39;; `: {}} } model.go  package sqlboy import &#34;time&#34; type OrderInfo struct { Id uint32 `db:&#34;id&#34; json:&#34;id&#34;` //自增ID 	OrderId string `db:&#34;order_id&#34; json:&#34;order_id&#34;` //订单号 	Status int8 `db:&#34;status&#34; json:&#34;status&#34;` //订单状态 	CreatedAt time.Time `db:&#34;created_at&#34; json:&#34;created_at&#34;` //创建时间 	UpdatedAt time.Time `db:&#34;updated_at&#34; json:&#34;updated_at&#34;` //修改时间 } func (*OrderInfo) TableName() string { return `order_info` } dao.go  package sqlboy import ( &#34;context&#34; &#34;github.com/jmoiron/sqlx&#34; ) type contextTxKey struct{} type Dao struct { db *sqlx.DB } func NewDao(db *sqlx.DB) *Dao { return &amp;Dao{ db: db, } } func (d *Dao) InTx(ctx context.Context, fn func(ctx context.Context) error) error { tx, err := d.db.Begin() if err != nil { return err } defer func() { _ = tx.Rollback() }() err = fn(context.WithValue(ctx, contextTxKey{}, tx)) if err != nil { return err } return tx.Commit() } func (d *Dao) DB(ctx context.Context) DbTx { tx, ok := ctx.Value(contextTxKey{}).(*sqlx.Tx) if ok { return tx } return d.db } transaction.go  package sqlboy import ( &#34;context&#34; &#34;database/sql&#34; &#34;github.com/jmoiron/sqlx&#34; ) type Transaction interface { InTx(context.Context, func(ctx context.Context) error) error } func NewTransaction(d *Dao) Transaction { return d } type DbTx interface { QueryRowxContext(ctx context.Context, query string, args ...interface{}) *sqlx.Row QueryxContext(ctx context.Context, query string, args ...interface{}) (*sqlx.Rows, error) NamedExecContext(ctx context.Context, query string, arg interface{}) (sql.Result, error) ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error) } query_table.go (这个文件只展示一部分)  package sqlboy import &#34;context&#34; type OrderInfoDao interface { CreateOrderInfo(ctx context.Context, orderInfo *OrderInfo) error BatchCreateOrderInfo(ctx context.Context, list []*OrderInfo, batchSize int) error FindOrderInfo(ctx context.Context, id uint32) (*OrderInfo, error) UpdateOrderInfo(ctx context.Context, orderInfo *OrderInfo) error DeleteOrderInfo(ctx context.Context, id uint32) error FindByOrderId(ctx context.Context, orderId string) (*OrderInfo, error) UpdateByOrderId(ctx context.Context, orderInfo *OrderInfo) error DeleteByOrderId(ctx context.Context, orderId string) error } type OrderInfoImpl struct { dao *Dao } func NewOrderInfoDao(dao *Dao) OrderInfoDao { return &amp;OrderInfoImpl{ dao: dao, } } func (d *OrderInfoImpl) CreateOrderInfo(ctx context.Context, orderInfo *OrderInfo) error { _, err := d.dao.DB(ctx).NamedExecContext(ctx, &#34;INSERT INTO `order_info` (`id`,`order_id`,`status`,`created_at`,`updated_at`) VALUES (:id,:order_id,:status,:created_at,:updated_at)&#34;, orderInfo) return err } func (d *OrderInfoImpl) BatchCreateOrderInfo(ctx context.Context, list []*OrderInfo, batchSize int) error { return d.dao.InTx(ctx, func(ctx context.Context) error { for i := 0; i &lt; len(list); i += batchSize { ends := i + batchSize if ends &gt; len(list) { ends = len(list) } _, err := d.dao.DB(ctx).NamedExecContext(ctx, &#34;INSERT INTO `order_info` (`id`,`order_id`,`status`,`created_at`,`updated_at`) VALUES (:id,:order_id,:status,:created_at,:updated_at)&#34;, list[i:ends]) if err != nil { return err } } return nil }) } 设计  go AST
这个在前文有提到过，用来做输入的解析，建表语句的读取。这里我还把部分输出任务也给了他 （其实输出不应该用AST，效率低，且难以维护，这里只是为了尝试） ANTLR vs yacc
调研的时候发现很多ddl to struct的项目都是直接引用的一个使用yacc解析sql的库。 不过在经过对比之后，我发现yacc比较古老，而且还得自己去实现分词，因此直接放弃，采用更先进的ANTLR。 go template
输出是用的go原生text/template渲染，为了减少依赖，除了ANTLR，就没打算用第三方库。  整体架构 小结 这是sqlboy这个系列的第一篇文章，主要是写自己的想法由来，后续还将打算写四篇文章讲述具体实现细节。 这个项目已经完成了，欢迎大家使用并给我提bug。
项目源码 https://github.com/lemon-1997/sqlboy  
]]></content></entry><entry><title>如何在go中写好单元测试</title><url>/post/best-test.html</url><categories><category>最佳实践</category></categories><tags><tag>go</tag><tag>单元测试</tag></tags><content type="html"><![CDATA[当你还在用postman测试你的api时，那表明你还没找到使用go的最佳姿势，阅读这篇文章，一起来了解下go内置的测试框架，这会对你有所帮助。
单元测试 单元测试是我们项目开发中不可缺少的一部分，如果一个go项目没有单元测试，且刚好项目交接到你手里，由你来维护，那会很棘手，没有测试，意味着无法掌控这个项目，它就像一个定时炸弹，随时会产生bug。作为程序员，我们必须好好了解下单元测试。
单元测试基本概念  单元测试：应用中最小可测试部分，能够单独运行，用于被检测代码是否按照预期工作 测试用例：是一组测试，包括输入，执行条件，以及预期结果等 覆盖率：测试的度量，用来衡量代码被测试的比例 测试驱动开发：先有测试，后再通过修改代码使测试通过的开发方式  单元测试的优点  易于调试 提前发现问题 短代码，简洁且高质量  可能有人会觉得写单元测试是一件很麻烦的事，认为浪费时间。但也许你写了单元测试，他能减少你项目出问题排错的时间，也能让你更好的运行指定的代码，更精准的找到问题。写单元测试其实为你带来了效率上的提升，并且在go中，为项目增加单元测试非常简单。
go内置测试框架 go官方包自带了测试框架，这不仅仅是go官方为了所有gopher能更方便的写测试，也直接证明了测试的重要性，官方直接把他丢进了std里，可见一斑。 在最新版本的go中，go团队加入了模糊测试，不过本篇文章只涉及单元测试，不会讲解基准测试以及模糊测试。
testing.T 在go中写单元测试，我们先写了解下 testing.T 这个类型以及其持有的方法
// TB is the interface common to T and B. type TB interface { Cleanup(func()) Error(args ...interface{}) Errorf(format string, args ...interface{}) Fail() FailNow() Failed() bool Fatal(args ...interface{}) Fatalf(format string, args ...interface{}) Helper() Log(args ...interface{}) Logf(format string, args ...interface{}) Name() string Skip(args ...interface{}) SkipNow() Skipf(format string, args ...interface{}) Skipped() bool TempDir() string // A private method to prevent users implementing the  // interface and so future additions to it will not  // violate Go 1 compatibility.  private() } type T struct { common isParallel bool context *testContext // For running tests and subtests. } var _ TB = (*T)(nil) 这里顺便给大家科普下，var _ TB = (*T)(nil) 这行语句，使用了编译时断言，如果 T 没有实现 TB 里定义的方法，那么编译就会报错，这样能让开发者及时发现问题，避免错误的发生。大家平常写代码也可以使用编译时断言来让自己的项目更加健壮。
常用方法
 Logf：记录日志，提供代码测试时运行信息 Errorf：记录日志，但会让测试不能通过 Fatalf：记录日志，测试立即停止且测试失败 Skipf：记录日志，并跳过该测试函数 Cleanup：清理函数，资源的释放 Helper：辅助函数，打印文件行信息  官方例子 testing.T 看起来比较简单，老规矩，先上官方例子
package greetings import ( &#34;testing&#34; &#34;regexp&#34; ) // TestHelloName calls greetings.Hello with a name, checking // for a valid return value. func TestHelloName(t *testing.T) { name := &#34;Gladys&#34; want := regexp.MustCompile(`\b`+name+`\b`) msg, err := Hello(&#34;Gladys&#34;) if !want.MatchString(msg) || err != nil { t.Fatalf(`Hello(&#34;Gladys&#34;) = %q, %v, want match for %#q, nil`, msg, err, want) } } // TestHelloEmpty calls greetings.Hello with an empty string, // checking for an error. func TestHelloEmpty(t *testing.T) { msg, err := Hello(&#34;&#34;) if msg != &#34;&#34; || err == nil { t.Fatalf(`Hello(&#34;&#34;) = %q, %v, want &#34;&#34;, error`, msg, err) } } 上面的例子大家应该都看得懂，我就不总结具体的测试流程了，这里主要是为了给大家展示在go中写单元测试是多么方便。
最佳实践 starting 在开始之前，我们要先了解go的测试规范
 文件名：前缀为测试代码的文件名，以 _test.go 结尾（go build 会忽略这些文件） 文件位置：位于测试的代码同一 package 下 函数名：Test 为前缀，后面是测试函数名，函数参数为 *testing.T  table test table test 是一种很棒的写法，它能让你的测试代码足够清晰，让你的测试用例易于维护，该写法可以在各种库中见到。其大体流程为：
 定义tests 为测试用例，其结构为匿名结构体切片 []struct{} 补充匿名结构体变量，定义好输入输出，丰富测试用例 遍历测试用例，调用测试方法，判断测试结果是否符合预期 使用 testing.T 里的方法记录日志或让测试失败  go源码 encoding/json/encode_test.go 里就采用了这种测试方式
func TestRoundtripStringTag(t *testing.T) { tests := []struct { name string in StringTag want string // empty to just test that we roundtrip 	}{ { name: &#34;AllTypes&#34;, in: StringTag{ BoolStr: true, IntStr: 42, UintptrStr: 44, StrStr: &#34;xzbit&#34;, NumberStr: &#34;46&#34;, }, want: `{ &#34;BoolStr&#34;: &#34;true&#34;, &#34;IntStr&#34;: &#34;42&#34;, &#34;UintptrStr&#34;: &#34;44&#34;, &#34;StrStr&#34;: &#34;\&#34;xzbit\&#34;&#34;, &#34;NumberStr&#34;: &#34;46&#34; }`, }, { // See golang.org/issues/38173. 	name: &#34;StringDoubleEscapes&#34;, in: StringTag{ StrStr: &#34;\b\f\n\r\t\&#34;\\&#34;, NumberStr: &#34;0&#34;, // just to satisfy the roundtrip 	}, want: `{ &#34;BoolStr&#34;: &#34;false&#34;, &#34;IntStr&#34;: &#34;0&#34;, &#34;UintptrStr&#34;: &#34;0&#34;, &#34;StrStr&#34;: &#34;\&#34;\\u0008\\u000c\\n\\r\\t\\\&#34;\\\\\&#34;&#34;, &#34;NumberStr&#34;: &#34;0&#34; }`, }, } for _, test := range tests { t.Run(test.name, func(t *testing.T) { // Indent with a tab prefix to make the multi-line string 	// literals in the table nicer to read. 	got, err := MarshalIndent(&amp;test.in, &#34;\t\t\t&#34;, &#34;\t&#34;) if err != nil { t.Fatal(err) } if got := string(got); got != test.want { t.Fatalf(&#34; got: %s\nwant: %s\n&#34;, got, test.want) } // Verify that it round-trips. 	var s2 StringTag if err := Unmarshal(got, &amp;s2); err != nil { t.Fatalf(&#34;Decode: %v&#34;, err) } if !reflect.DeepEqual(test.in, s2) { t.Fatalf(&#34;decode didn&#39;t match.\nsource: %#v\nEncoded as:\n%s\ndecode: %#v&#34;, test.in, string(got), s2) } }) } } mock test 当我们由于某些原因，不好直接调用我们的函数去做测试时，我们应该如何做呢？答案就是 interface ，如果我们的测试函数输入刚好是 interface 时，那很棒，如果不是呢，考虑下将函数参数抽象为 interfae ，是否你的代码会更好。
直接看下面的例子，这也是来自go源码 io/io_test.go
type zeroErrReader struct { err error } func (r zeroErrReader) Read(p []byte) (int, error) { return copy(p, []byte{0}), r.err } type errWriter struct { err error } func (w errWriter) Write([]byte) (int, error) { return 0, w.err } // In case a Read results in an error with non-zero bytes read, and // the subsequent Write also results in an error, the error from Write // is returned, as it is the one that prevented progressing further. func TestCopyReadErrWriteErr(t *testing.T) { er, ew := errors.New(&#34;readError&#34;), errors.New(&#34;writeError&#34;) r, w := zeroErrReader{err: er}, errWriter{err: ew} n, err := Copy(w, r) if n != 0 || err != ew { t.Errorf(&#34;Copy(zeroErrReader, errWriter) = %d, %v; want 0, writeError&#34;, n, err) } } 这里通过 zeroErrReader 和 errWriter mock数据，分别实现了 io.Reader 以及 io.Writer ，当我们写测试时，具体怎样mock取决于你想测试的东西。
dependency injection 有些时候，我们的测试需要外部依赖，例如我们需要数据库实例或者http server，这时候我们可以利用 TestMain 的特性
来看看go源码 net/http/main_test.go
func TestMain(m *testing.M) { setupTestData() installTestHooks() st := m.Run() testHookUninstaller.Do(uninstallTestHooks) if testing.Verbose() { printRunningGoroutines() printInflightSockets() printSocketStats() } forceCloseSockets() os.Exit(st) } 执行测试的时候，会优先执行 TestMain ，然后再通过 m.Run() 执行其他的测试，最好释放我们的资源，这样就解决了我们的资源依赖问题。这里给出一个模板参考，具体的 setup() 和 teardown() 的实现由自己的项目代码所决定。
func setup() { fmt.Printf(&#34;Setup&#34;) } func teardown() { fmt.Printf(&#34;Teardown&#34;) } func TestMain(m *testing.M) { setup() code := m.Run() teardown() os.Exit(code) } 结语 这篇文章所讲的东西都是自己最近写单元测试的一些感悟，如果有错误可在下方评论指出，如果对你有帮助，我也很希望在评论区看到你的评论。 好了，到这里就结束了，感谢阅读！
]]></content></entry><entry><title>mysql事务在go语言中的正确打开方式</title><url>/post/best-transaction.html</url><categories><category>最佳实践</category></categories><tags><tag>go</tag><tag>mysql</tag></tags><content type="html"><![CDATA[相信大家在做curd项目时经常会使用到mysql中的事务，这篇文章将会展示在go中实现mysql事务的几种方式，希望阅读后能够给你带来启发。
mysql事务 mysql的事务保证了我们应用程序和业务逻辑的可靠，是我们日常开发重要的一环，我们必须了解其特性，才能更好的使用它。
ACID模型 首先介绍下 ACID 模型
 A：原子性。事务中的操作要么 commit 成功，要么全部 rollback C：一致性。事务的执行前后数据要一致，主要是保护数据丢失，比如 innodb 中的崩溃恢复机制 I：隔离性。事务内部的操作与其他事务的隔离，比如隔离级别以及锁机制 D：持久性。事务提交后对数据库具有永久性  使用场景 上面的ACID其实已经可以体现出事务的使用场景。举几个例子
 用户下单时，需要在订单表创建一条记录，并扣减商品的库存 转账时，一方扣款，另一方必须增加对应的金额 查询到其他事务还没有提交的数据，导致脏读  了解了什么是事务，接下来我们一起看下在go中是怎么开启事务。
go实现方式 go开启事务的几个步骤
 开启事务 执行数据库操作 结束事务  提交事务 回滚事务    看起来很简单，就三个步骤而已，下面看下具体的代码实例。
go官方例子 先欣赏下go官方提供的例子
// CreateOrder creates an order for an album and returns the new order ID. func CreateOrder(ctx context.Context, albumID, quantity, custID int) (orderID int64, err error) { // Create a helper function for preparing failure results.  fail := func(err error) (int64, error) { return fmt.Errorf(&#34;CreateOrder: %v&#34;, err) } // Get a Tx for making transaction requests.  tx, err := db.BeginTx(ctx, nil) if err != nil { return fail(err) } // Defer a rollback in case anything fails.  defer tx.Rollback() // Confirm that album inventory is enough for the order.  var enough bool if err = tx.QueryRowContext(ctx, &#34;SELECT (quantity &gt;= ?) from album where id = ?&#34;, quantity, albumID).Scan(&amp;enough); err != nil { if err == sql.ErrNoRows { return fail(fmt.Errorf(&#34;no such album&#34;)) } return fail(err) } if !enough { return fail(fmt.Errorf(&#34;not enough inventory&#34;)) } // Update the album inventory to remove the quantity in the order.  _, err = tx.ExecContext(ctx, &#34;UPDATE album SET quantity = quantity - ? WHERE id = ?&#34;, quantity, albumID) if err != nil { return fail(err) } // Create a new row in the album_order table.  result, err := tx.ExecContext(ctx, &#34;INSERT INTO album_order (album_id, cust_id, quantity, date) VALUES (?, ?, ?, ?)&#34;, albumID, custID, quantity, time.Now()) if err != nil { return fail(err) } // Get the ID of the order item just created.  orderID, err := result.LastInsertId() if err != nil { return fail(err) } // Commit the transaction.  if err = tx.Commit(); err != nil { return fail(err) } // Return the order ID.  return orderID, nil } 这是go官方提供的例子，大体的代码流程如下
 通过 DB.Begin / DB.BeginTx 获取 sql.Tx 延迟调用 Tx.Rollback 执行数据库的插入修改语句 没有出错，通过 Tx.Commit 提交  这种方式看起来很不错，失败了能回滚，成功则一起提交，很清晰的表明事务的整个流程。 但是当你项目的业务逻辑愈加复杂，或者事务里面的某个表新加了字段，需要去调整SQL语句的时候，你必须在这个大函数里面去修改，这看起来很危险。 像这个例子所体现的，该函数里面做了多个SQL操作，除了单一的业务场景，很难被别的地方复用。
mysql事务封装 于是，针对上面的问题，可以先将事务的操作封装起来，并抽离出数据库执行SQL的函数 fn
func WithTransaction(db *sql.DB, fn func(sql.Tx) error) (err error) { tx, err := db.Begin() if err != nil { return } defer func() { if p := recover(); p != nil { // a panic occurred, rollback and repanic 	tx.Rollback() panic(p) } else if err != nil { // something went wrong, rollback 	tx.Rollback() } else { // all good, commit 	err = tx.Commit() } }() err = fn(tx) return err } 因此使用起来只需要编写相应的数据库操作函数 fn，我们可以对订单，商品数据的操作做更细粒度的封装，就像下面这样
err = WithTransaction(db, func(tx sql.Tx) error { // insert a record into order table 	res, err := dao.CreateOrder(tx,order) if err != nil { return err } // update product inventory 	res, err = dao.UpdateInventory(tx,product) if err != nil { return err } }) 好了，目前看来这个例子已经很完美了，我们不需要写过多的重复代码，事务的操作，数据库执行的SQL都能被很好的复用。 但是还有个问题，上面的 CreateOrder 和 UpdateInventory 函数需要传入 sql.Tx，这会使调用者难以下手，理论上调用者不应该关心传入哪个数据库，他只想完成创建订单，扣减库存的操作。 而且，当你的事务只需要执行一次SQL时，并不需要开启事务的，但你的传参确实 sql.Tx，这会导致多余的代码，且很不优雅。
interface登场 假设我们现在有一个数据库操作对象 Dao
type Dao struct{ db *sql.Db } func (d *Dao ) CreateOrder(ctx context, order entity.Order) error { d.db.ExecContext(ctx, `Insert into`, order) } func (d *Dao ) UpdateInventory(ctx context, product entity.Product) error { d.db.ExecContext(ctx, `Insert into`, product) } 如果我们现在需要开启一个事务，这个事务里需要执行 CreateOrder 和 UpdateInventory，这个时候，很多人的第一个想法是重新写一个函数，因为现有的函数都是由 sql.Db 去执行，而不是 sql.Tx。 那我们有没有办法减少重复代码的开发呢？答案是有的，那就是 interface{}
// Queries is a common interface that is used by both *sqlx.DB and *sqlx.Tx. type Queries interface { QueryRowxContext(ctx context.Context, query string, args ...interface{}) *sqlx.Row QueryxContext(ctx context.Context, query string, args ...interface{}) (*sqlx.Rows, error) NamedExecContext(ctx context.Context, query string, arg interface{}) (sql.Result, error) ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error) } 在这里，我们定义了一个叫 Queries 的 interface 去实现 sql.Db 和 sql.Tx 。那么再对 Dao 重新调整一下，并对外提供一个 New 函数，支持传入 sql.Db 和 sql.Tx
type Dao struct{ db Queries } fun NewOderDao (db Queries) *Dao{ return &amp;oderDao{db:db} } 这样一来，我们通过 Queries 使 Dao 中的函数可以同时是普通执行或者开启事务执行，且调用相关函数时不需要传入数据库对象。那么问题来了，如何与上面封装好的 WithTransaction一起使用呢？
best practices 上面的 WithTransaction 函数注入了 sql.Tx，那么，我们可以将两者结合，改变一下注入对象，将 Dao 注入给 fn
func WithTransaction(db *sql.DB, fn func(dao *Dao) error) (err error) { tx, err := db.Beginx() if err != nil { return } defer func() { if p := recover(); p != nil { // a panic occurred, rollback and repanic 	tx.Rollback() panic(p) } else if err != nil { // something went wrong, rollback 	tx.Rollback() } else { // all good, commit 	err = tx.Commit() } }() // inject 	dao := NewOderDao(tx) err = fn(dao) return err } 这样一来，调用 WithTransaction 就可以拿到数据库操作对象了。最后别忘了补充单元测试，那是你go项目中可靠性以及可维护性的一部分
// init db dao func init(){ } func Test_WithTransaction(t *testing.T) { tests := []struct{ fn func(dao *Dao)error // out? or else  }{ { func(dao *Dao)error{ ctx, cancel := context.WithCancel(context.Background()) cancel() err := dao.CreateOrderInfo(ctx, &amp;order) if err != nil { t.Logf(&#34;error %v emit roollback&#34;, err) return err } t.Logf(&#34;comit order %v&#34;, order) return nil }, }, { func(dao *Dao)error{ return nil }, }, } for _, tt := range tests{ _ = WithTransaction(db, tt.fn) } } 结语 关于mysql的事务操作，相信还有更优秀的写法，这篇文章的例子也许不是最好的，但希望能给你带来启发，有兴趣的可以在下方评论与我交流。
]]></content></entry><entry><title>后端开发必备的工具及网站</title><url>/post/other-develop.html</url><categories><category>随想记录</category></categories><tags><tag>后端</tag></tags><content type="html">other-develop</content></entry><entry><title>Kratos的设计哲学</title><url>/post/frame-kratos.html</url><categories><category>框架教程</category></categories><tags><tag>go</tag><tag>kratos</tag></tags><content type="html">frame-kratos</content></entry><entry><title>go上下文Context包源码分析</title><url>/post/source-context.html</url><categories><category>源码分析</category></categories><tags><tag>go</tag><tag>context</tag></tags><content type="html">source-context</content></entry><entry><title>lemon</title><url>/about/</url><categories/><tags><tag>lemon</tag></tags><content type="html">大家好，我是lemon，目前在深圳从事互联网相关的工作。从事后端开发已经有几年时间了，主要使用的语言是go，平常喜欢去研究go，一直致力于写出更优雅的go代码。建立此博客的初衷一是为了分享给其他人，二是自己分享了，也会去总结，自己能够有所收获。
博客专题 最佳实践 源码分析 项目实战 框架教程 随想记录 博客地址 国内： https://lemon-1997.pages.dev/ 国外： https://lemon-1997.github.io/ 联系方式 Github： https://github.com/lemon-1997 邮箱：lemom_ 1997@126.com 评论：参与下方评论与我交流</content></entry></search>