<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>mysql事务在go语言中的正确打开方式</title><url>https://lemon-1997.github.io/post/best-transaction.html</url><categories><category>最佳实践</category></categories><tags><tag>go</tag><tag>mysql</tag></tags><content type="html"><![CDATA[相信大家在做curd项目时经常会使用到mysql中的事务，这篇文章将会展示在go中实现mysql事务的几种方式，希望阅读后能够给你带来启发。
mysql事务 mysql的事务保证了我们应用程序和业务逻辑的可靠，是我们日常开发重要的一环，我们必须了解其特性，才能更好的使用它。
ACID模型 首先介绍下 ACID 模型
 A：原子性。事务中的操作要么 commit 成功，要么全部 rollback C：一致性。事务的执行前后数据要一致，主要是保护数据丢失，比如 innodb 中的崩溃恢复机制 I：隔离性。事务内部的操作与其他事务的隔离，比如隔离级别以及锁机制 D：持久性。事务提交后对数据库具有永久性  使用场景 上面的ACID其实已经可以体现出事务的使用场景。举几个例子
 用户下单时，需要在订单表创建一条记录，并扣减商品的库存 转账时，一方扣款，另一方必须增加对应的金额 查询到其他事务还没有提交的数据，导致脏读  了解了什么是事务，接下来我们一起看下在go中是怎么开启事务。
go实现方式 go开启事务的几个步骤
 开启事务 执行数据库操作 结束事务  提交事务 回滚事务    看起来很简单，就三个步骤而已，下面看下具体的代码实例。
go官方例子 先欣赏下go官方提供的例子
1// CreateOrder creates an order for an album and returns the new order ID. 2func CreateOrder(ctx context.Context, albumID, quantity, custID int) (orderID int64, err error) { 3 4 // Create a helper function for preparing failure results. 5 fail := func(err error) (int64, error) { 6 return fmt.Errorf(&#34;CreateOrder: %v&#34;, err) 7 } 8 9 // Get a Tx for making transaction requests. 10 tx, err := db.BeginTx(ctx, nil) 11 if err != nil { 12 return fail(err) 13 } 14 // Defer a rollback in case anything fails. 15 defer tx.Rollback() 16 17 // Confirm that album inventory is enough for the order. 18 var enough bool 19 if err = tx.QueryRowContext(ctx, &#34;SELECT (quantity &gt;= ?) from album where id = ?&#34;, 20quantity, albumID).Scan(&amp;enough); err != nil { 21	if err == sql.ErrNoRows { 22 return fail(fmt.Errorf(&#34;no such album&#34;)) 23 } 24 return fail(err) 25 } 26 if !enough { 27 return fail(fmt.Errorf(&#34;not enough inventory&#34;)) 28 } 29 30 // Update the album inventory to remove the quantity in the order. 31 _, err = tx.ExecContext(ctx, &#34;UPDATE album SET quantity = quantity - ? WHERE id = ?&#34;, 32quantity, albumID) 33	if err != nil { 34	return fail(err) 35	} 36 37 // Create a new row in the album_order table. 38 result, err := tx.ExecContext(ctx, 39	&#34;INSERT INTO album_order (album_id, cust_id, quantity, date) VALUES (?, ?, ?, ?)&#34;, 40albumID, custID, quantity, time.Now()) 41 if err != nil { 42 return fail(err) 43 } 44 // Get the ID of the order item just created. 45 orderID, err := result.LastInsertId() 46 if err != nil { 47 return fail(err) 48 } 49 50 // Commit the transaction. 51 if err = tx.Commit(); err != nil { 52 return fail(err) 53 } 54 55 // Return the order ID. 56 return orderID, nil 57} 这是go官方提供的例子，大体的代码流程如下
 通过 DB.Begin / DB.BeginTx 获取 sql.Tx 延迟调用 Tx.Rollback 执行数据库的插入修改语句 没有出错，通过 Tx.Commit 提交  这种方式看起来很不错，失败了能回滚，成功则一起提交，很清晰的表明事务的整个流程。 但是当你项目的业务逻辑愈加复杂，或者事务里面的某个表新加了字段，需要去调整SQL语句的时候，你必须在这个大函数里面去修改，这看起来很危险。 像这个例子所体现的，该函数里面做了多个SQL操作，除了单一的业务场景，很难被别的地方复用。
mysql事务封装 于是，针对上面的问题，可以先将事务的操作封装起来，并抽离出数据库执行SQL的函数 fn
1func WithTransaction(db *sql.DB, fn func(sql.Tx) error) (err error) { 2	tx, err := db.Begin() 3	if err != nil { 4	return 5	} 6 7	defer func() { 8	if p := recover(); p != nil { 9	// a panic occurred, rollback and repanic 10	tx.Rollback() 11	panic(p) 12	} else if err != nil { 13	// something went wrong, rollback 14	tx.Rollback() 15	} else { 16	// all good, commit 17	err = tx.Commit() 18	} 19	}() 20 21	err = fn(tx) 22	return err 23} 因此使用起来只需要编写相应的数据库操作函数 fn，我们可以对订单，商品数据的操作做更细粒度的封装，就像下面这样
1err = WithTransaction(db, func(tx sql.Tx) error { 2	// insert a record into order table 3	res, err := dao.CreateOrder(tx,order) 4	if err != nil { 5	return err 6	} 7	8	// update product inventory 9	res, err = dao.UpdateInventory(tx,product) 10	if err != nil { 11	return err 12	} 13}) 好了，目前看来这个例子已经很完美了，我们不需要写过多的重复代码，事务的操作，数据库执行的SQL都能被很好的复用。 但是还有个问题，上面的 CreateOrder 和 UpdateInventory 函数需要传入 sql.Tx，这会使调用者难以下手，理论上调用者不应该关心传入哪个数据库，他只想完成创建订单，扣减库存的操作。 而且，当你的事务只需要执行一次SQL时，并不需要开启事务的，但你的传参确实 sql.Tx，这会导致多余的代码，且很不优雅。
interface登场 假设我们现在有一个数据库操作对象 Dao
1type Dao struct{ 2	db *sql.Db 3} 4 5func (d *Dao ) CreateOrder(ctx context, order entity.Order) error { 6 d.db.ExecContext(ctx, `Insert into`, order) 7} 8 9func (d *Dao ) UpdateInventory(ctx context, product entity.Product) error { 10 d.db.ExecContext(ctx, `Insert into`, product) 11} 如果我们现在需要开启一个事务，这个事务里需要执行 CreateOrder 和 UpdateInventory，这个时候，很多人的第一个想法是重新写一个函数，因为现有的函数都是由 sql.Db 去执行，而不是 sql.Tx。 那我们有没有办法减少重复代码的开发呢？答案是有的，那就是 interface{}
1// Queries is a common interface that is used by both *sqlx.DB and *sqlx.Tx. 2type Queries interface { 3 QueryRowxContext(ctx context.Context, query string, args ...interface{}) *sqlx.Row 4 QueryxContext(ctx context.Context, query string, args ...interface{}) (*sqlx.Rows, error) 5 NamedExecContext(ctx context.Context, query string, arg interface{}) (sql.Result, error) 6 ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error) 7} 在这里，我们定义了一个叫 Queries 的 interface 去实现 sql.Db 和 sql.Tx 。那么再对 Dao 重新调整一下，并对外提供一个 New 函数，支持传入 sql.Db 和 sql.Tx
1type Dao struct{ 2 db Queries 3} 4 5fun NewOderDao (db Queries) *Dao{ 6 return &amp;oderDao{db:db} 7} 这样一来，我们通过 Queries 使 Dao 中的函数可以同时是普通执行或者开启事务执行，且调用相关函数时不需要传入数据库对象。那么问题来了，如何与上面封装好的 WithTransaction一起使用呢？
best practices 上面的 WithTransaction 函数注入了 sql.Tx，那么，我们可以将两者结合，改变一下注入对象，将 Dao 注入给 fn
1func WithTransaction(db *sql.DB, fn func(dao *Dao) error) (err error) { 2	tx, err := db.Beginx() 3	if err != nil { 4	return 5	} 6 7	defer func() { 8	if p := recover(); p != nil { 9	// a panic occurred, rollback and repanic 10	tx.Rollback() 11	panic(p) 12	} else if err != nil { 13	// something went wrong, rollback 14	tx.Rollback() 15	} else { 16	// all good, commit 17	err = tx.Commit() 18	} 19	}() 20 21	// inject 22	dao := NewOderDao(tx) 23 24	err = fn(dao) 25	return err 26} 这样一来，调用 WithTransaction 就可以拿到数据库操作对象了。最后别忘了补充单元测试，那是你go项目中可靠性以及可维护性的一部分
1// init db dao 2func init(){ 3	4} 5 6func Test_WithTransaction(t *testing.T) { 7 tests := []struct{ 8 fn func(dao *Dao)error 9 // out? or else 10 }{ 11 { 12 func(dao *Dao)error{ 13 ctx, cancel := context.WithCancel(context.Background()) 14 cancel() 15 err := dao.CreateOrderInfo(ctx, &amp;order) 16 if err != nil { 17 t.Logf(&#34;error %v emit roollback&#34;, err) 18 return err 19 } 20 t.Logf(&#34;comit order %v&#34;, order) 21 return nil 22 }, 23 }, 24 { 25 func(dao *Dao)error{ 26 return nil 27 }, 28 }, 29 } 30 for _, tt := range tests{ 31 _ = WithTransaction(db, tt.fn) 32 } 33} 34 结语 关于mysql的事务操作，相信还有更优秀的写法，这篇文章的例子也许不是最好的，但希望能给你带来启发，有兴趣的可以在下方评论与我交流。
]]></content></entry><entry><title>如何在go中写好单元测试</title><url>https://lemon-1997.github.io/post/best-test.html</url><categories><category>最佳实践</category></categories><tags><tag>go</tag><tag>单元测试</tag></tags><content type="html"><![CDATA[当你还在用postman测试你的api时，那表明你还没找到使用go的最佳姿势，阅读这篇文章，一起来了解下go内置的测试框架，这会对你有所帮助。
单元测试 什么是单元测试 覆盖率 单元测试的优点 go内置测试框架 go官方包自带了测试框架，这不仅仅是go官方为了所有gopher能更方便的写测试，也直接证明了测试的重要性，官方直接把他丢进了std里，可见一斑。 在最新版本的go中，go团队加入了模糊测试，不过本篇文章只涉及单元测试，不会讲解基准测试以及模糊测试。
testing.T 在go中写单元测试，我们先写了解下 testing.T 这个类型以及其持有的方法
1// TB is the interface common to T and B. 2type TB interface { 3 Cleanup(func()) 4 Error(args ...interface{}) 5 Errorf(format string, args ...interface{}) 6 Fail() 7 FailNow() 8 Failed() bool 9 Fatal(args ...interface{}) 10 Fatalf(format string, args ...interface{}) 11 Helper() 12 Log(args ...interface{}) 13 Logf(format string, args ...interface{}) 14 Name() string 15 Skip(args ...interface{}) 16 SkipNow() 17 Skipf(format string, args ...interface{}) 18 Skipped() bool 19 TempDir() string 20 21 // A private method to prevent users implementing the 22 // interface and so future additions to it will not 23 // violate Go 1 compatibility. 24 private() 25} 26 27type T struct { 28 common 29 isParallel bool 30 context *testContext // For running tests and subtests. 31} 32 33var _ TB = (*T)(nil) 这里顺便给大家科普下，var _ TB = (*T)(nil) 这行语句，使用了编译型断言，如果 T 没有实现 TB 里定义的方法，那么编译就会报错，这样能让开发者及时发现问题，避免错误的发生。大家平常写代码也可以使用编译型断言来让自己的项目更加健壮。
常用方法
 Logf：记录日志，提供代码测试时运行信息 Errorf：记录日志，但会让测试不能通过 Fatalf：记录日志，测试立即停止且测试失败 Skipf：记录日志，并跳过该测试函数 Cleanup：清理函数，资源的释放 Helper：辅助函数，打印文件行信息  官方例子 testing.T 看起来比较简单，老规矩，先上官方例子
1package greetings 2 3import ( 4 &#34;testing&#34; 5 &#34;regexp&#34; 6) 7 8// TestHelloName calls greetings.Hello with a name, checking 9// for a valid return value. 10func TestHelloName(t *testing.T) { 11 name := &#34;Gladys&#34; 12 want := regexp.MustCompile(`\b`+name+`\b`) 13 msg, err := Hello(&#34;Gladys&#34;) 14 if !want.MatchString(msg) || err != nil { 15 t.Fatalf(`Hello(&#34;Gladys&#34;) = %q, %v, want match for %#q, nil`, msg, err, want) 16 } 17} 18 19// TestHelloEmpty calls greetings.Hello with an empty string, 20// checking for an error. 21func TestHelloEmpty(t *testing.T) { 22 msg, err := Hello(&#34;&#34;) 23 if msg != &#34;&#34; || err == nil { 24 t.Fatalf(`Hello(&#34;&#34;) = %q, %v, want &#34;&#34;, error`, msg, err) 25 } 26} 上面的例子大家应该都看得懂，我就不总结具体的测试流程了，这里主要是为了给大家展示在go中写单元测试是多么方便。
最佳实践 starting go测试规范 文件 函数命名规范
table test mock test (interface) db test (how to mock) set up tear down how to di]]></content></entry><entry><title>后端开发必备的工具及网站</title><url>https://lemon-1997.github.io/post/other-develop.html</url><categories><category>随想记录</category></categories><tags><tag>后端</tag></tags><content type="html">other-develop</content></entry><entry><title>Kratos的设计哲学</title><url>https://lemon-1997.github.io/post/frame-kratos.html</url><categories><category>框架教程</category></categories><tags><tag>go</tag><tag>kratos</tag></tags><content type="html">frame-kratos</content></entry><entry><title>实现go代码生成工具</title><url>https://lemon-1997.github.io/post/project-ddlGen.html</url><categories><category>项目实战</category></categories><tags><tag>go</tag><tag>generate</tag></tags><content type="html">project-ddl-gen</content></entry><entry><title>go上下文Context包源码分析</title><url>https://lemon-1997.github.io/post/source-context.html</url><categories><category>源码分析</category></categories><tags><tag>go</tag><tag>context</tag></tags><content type="html">source-context</content></entry><entry><title>lemon</title><url>https://lemon-1997.github.io/about/</url><categories/><tags><tag>lemon</tag></tags><content type="html">大家好，我是lemon，目前在深圳从事互联网相关的工作。从事后端开发已经有几年时间了，主要使用的语言是go，平常喜欢去研究go，一直致力于写出更优雅的go代码。建立此博客的初衷一是为了分享给其他人，二是自己分享了，也会去总结，自己能够有所收获。
博客专题 最佳实践 源码分析 项目实战 框架教程 随想记录 博客地址 国内：https://lemon-1997-github-io.vercel.app/ 国外：https://lemon-1997.github.io/ 联系方式 Github：https://github.com/lemon-1997 邮箱：lemom_ 1997@126.com 评论：参与下方评论与我交流</content></entry></search>