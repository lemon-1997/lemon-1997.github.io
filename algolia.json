[{"permalink":"/post/other-develop.html","title":"后端开发必备的工具及网站","content":"other-develop\n","date":"2022-08-15T21:58:49+08:00","updated":"2022-08-15T21:58:49+08:00"},{"permalink":"/post/frame-kratos.html","title":"Kratos的设计哲学","content":"frame-kratos\n","date":"2022-08-15T21:54:54+08:00","updated":"2022-08-15T21:54:54+08:00"},{"permalink":"/post/project-ddlGen.html","title":"实现go代码生成工具","content":"project-ddl-gen\n","date":"2022-08-15T21:50:53+08:00","updated":"2022-08-15T21:50:53+08:00"},{"permalink":"/post/source-context.html","title":"go上下文Context包源码分析","content":"source-context\n","date":"2022-08-15T21:47:46+08:00","updated":"2022-08-15T21:47:46+08:00"},{"permalink":"/post/best-test.html","title":"如何在go中写好单元测试","content":"best-test\n","date":"2022-08-15T21:44:12+08:00","updated":"2022-08-15T21:44:12+08:00"},{"permalink":"/post/best-transaction.html","title":"mysql事务在go语言中的正确打开方式","content":"相信大家在做curd项目时经常会使用到mysql中的事务，这篇文章将会展示在go中实现mysql事务的几种方式，希望阅读后能够给你带来启发。\nmysql事务 acid model\n a c i d  事务使用场景以及利弊\ngo实现方式 go开启事务的几个步骤\n 开启事务 执行数据库操作 结束事务  提交事务 回滚事务    go官方例子 先欣赏下go官方提供的例子\n1// CreateOrder creates an order for an album and returns the new order ID. 2func CreateOrder(ctx context.Context, albumID, quantity, custID int) (orderID int64, err error) { 3 4 // Create a helper function for preparing failure results. 5 fail := func(err error) (int64, error) { 6 return fmt.Errorf(\u0026#34;CreateOrder: %v\u0026#34;, err) 7 } 8 9 // Get a Tx for making transaction requests. 10 tx, err := db.BeginTx(ctx, nil) 11 if err != nil { 12 return fail(err) 13 } 14 // Defer a rollback in case anything fails. 15 defer tx.Rollback() 16 17 // Confirm that album inventory is enough for the order. 18 var enough bool 19 if err = tx.QueryRowContext(ctx, \u0026#34;SELECT (quantity \u0026gt;= ?) from album where id = ?\u0026#34;, 20quantity, albumID).Scan(\u0026amp;enough); err != nil { 21\tif err == sql.ErrNoRows { 22 return fail(fmt.Errorf(\u0026#34;no such album\u0026#34;)) 23 } 24 return fail(err) 25 } 26 if !enough { 27 return fail(fmt.Errorf(\u0026#34;not enough inventory\u0026#34;)) 28 } 29 30 // Update the album inventory to remove the quantity in the order. 31 _, err = tx.ExecContext(ctx, \u0026#34;UPDATE album SET quantity = quantity - ? WHERE id = ?\u0026#34;, 32quantity, albumID) 33\tif err != nil { 34\treturn fail(err) 35\t} 36 37 // Create a new row in the album_order table. 38 result, err := tx.ExecContext(ctx, 39\t\u0026#34;INSERT INTO album_order (album_id, cust_id, quantity, date) VALUES (?, ?, ?, ?)\u0026#34;, 40albumID, custID, quantity, time.Now()) 41 if err != nil { 42 return fail(err) 43 } 44 // Get the ID of the order item just created. 45 orderID, err := result.LastInsertId() 46 if err != nil { 47 return fail(err) 48 } 49 50 // Commit the transaction. 51 if err = tx.Commit(); err != nil { 52 return fail(err) 53 } 54 55 // Return the order ID. 56 return orderID, nil 57} 这是go官方提供的例子，大体的代码流程如下\n 通过 DB.Begin / DB.BeginTx 获取 sql.Tx 延迟调用 Tx.Rollback 执行数据库的插入修改语句 没有出差，通过 Tx.Commit 提交  这种方式看起来很不错，失败了能回滚，成功则一起提交，很清晰的表明事务的整个流程。 但是当你项目的业务逻辑愈加复杂，或者事务里面的某个表新加了字段，需要去调整SQL语句的适合，你必须在这个大函数里面去修改，这看起来很危险。 像这个例子所体现的，该函数里面做了多个SQL操作，除了单一的业务场景，很难被别的地方复用。\n错误示范 再来看下面这个例子，勿学\nbest practices 基于上面两者的结合，最佳实践在这，先看下代码实现\n总结","date":"2022-08-14T17:57:24+08:00","updated":"2022-08-15T21:40:00+08:00"},{"permalink":"/about/","title":"lemon","content":"大家好，我是lemon，目前在深圳从事互联网相关的工作。从事后端开发已经有几年时间了，主要使用的语言是go，平常喜欢去研究go，一直致力于写出更优雅的go代码。建立此博客的初衷一是为了分享给其他人，二是自己分享了，也会去总结，自己能够有所收获。\n博客专题  最佳实践 源码分析 项目实战 框架教程 随想记录  博客地址  国内：https://lemon-1997-github-io.vercel.app/ 国外：https://lemon-1997.github.io/  联系方式  Github：https://github.com/lemon-1997 邮箱：lemom_ 1997@126.com  评论：参与下方评论与我交流 ","date":"2022-08-09T22:17:49+08:00","updated":"2022-08-15T21:40:00+08:00"}]